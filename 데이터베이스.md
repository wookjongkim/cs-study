<details markdown = "1">
<summary>DBMS가 무엇인지와 왜 사용하는지 말해주세요.</summary>
DBMS(Database Management System)은 데이터베이스 관리 시스템으로, 응용 프로그램들이 DB를 공유하며 사용할 수 있는 환경을 제공합니다.<br>
기존 파일 시스템의 데이터 종속이나 중복, 무결성 훼손, 동시 접근의 문제 발생 등을 해결하기 위해 사용합니다.
</details>

<details markdown = "1">
<summary>DB를 사용하는 이유가 무엇이죠?</summary>

- 파일시스템의 데이터 중복, 비일관성, 검색 등의 문제를 해결하기 위해 사용
- 파일 시스템이 OS마다 다를 수 있기 때문에 OS에 종속적인 파일시스템을 이용하는 것은 프로그램의 확장성을 해침
</details>

<details markdown = "1">
<summary>스키마란 무엇이죠?</summary>
데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터 집합을 의미합니다.<br>
DB에서 데이터 개체, 속성, 관계를 형식언어로 정의한 구조로, DB 사용자가 자료를 저장, 조회, 삭제, 변경할때 DBMS는 자신이 생성한 데이터베이스 스키마를 참조해 명령을 수행하게 됩니다.<br>
</details>

<details markdown = "1">
<summary>뷰가 무엇인지 설명해주시고 장점과 단점이 무엇인지 설명해주세요.</summary>
뷰는 DB에 존재하는 가상 테이블이며, 실제 테이블처럼 행과 열을 가지고 있지만 실제로 데이터를 저장하진 않습니다.<br>
뷰를 사용하면 특정 사용자에게 테이블 전체가 아닌 필요한 칼럼만 보여줄 수 있고, 복잡한 쿼리를 단순화해서 사용하고 재사용할 수 있다는 장점이 있습니다.<br>
그러나 한번 정의된 뷰는 변경할수 없고, 원래 테이블의 내용을 직접 수정해야 합니다.<br>
<br>
참고 - 실제 데이터를 저장하지 않기 때문에 경우에 따라 다수의 쿼리가 발생하여 성능 이슈가 생길 수 있음, 인덱스 가질 수 없음
</details>

<details markdown = "1">
<summary>DB에서 사용하는 '키'에 대해 설명하고, 키의 종류에 대해 설명이 가능할까요?</summary>
키란 데이터베이스 내의 레코드나 튜플을 고유하게 식별하거나 접근할때 사용됩니다.<br>
슈퍼키는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로 유일성은 만족하지만, 최소성은 만족하지 못합니다.<br>
후보키는 기본 키가 될수 있는 후보가 되는 키들을 의미하고, 슈퍼키 중에서 최소성을 만족하는 키를 의미합니다.(즉 유일성 최소성 둘다 만족)<br>
기본키는 후보키 중에서 선택된 키로, 해당 릴레이션에서 튜플을 유일하게 식별할 수 있습니다.(null 및 중복 허용 X)<br>
대체키는 기본키로 선택되지 않은 나머지 후보키들을 의미하고, 복합키는 두개 이상의 속성으로 구성된 키입니다.<br>
외래키는 한 테이블의 키 중에서 다른 테이블의 레코드를 유일하게 식별할 수 있는 키를 의미합니다.<br>
</details>

<details markdown = "1">
<summary>트랜잭션이 무엇인지 설명해주세요.</summary>
데이터베이스의 상태를 변화시키는 하나의 논리적 작업 단위를 의미합니다.<br>
논리적인 작업의 쿼리 개수와 관계 없이 트랜잭션으로 묶어놓은 작업 단위 전체가 모두 적용되거나 아무것도 적용되지 않음을 보장합니다.<br>
<br>
꼬리질문1 - 트랜잭션의 특징은 무엇이 있을까요?<br>
트랜잭션의 특징은 앞글자를 따서 ACID라고 부릅니다.<br>
원자성(Atomicity)은 트랜잭션을 구성하는 연산 전체가 모두 정상적으로 실행되거나 모두 취소되어야 한다는 특성입니다.<br>
일관성(Consistency)은 트랜잭션이 실행되기 전과 후에 데이터베이스가 일관된 상태를 유지해야 한다는 것을 의미합니다.<br>
고립성(Isolation)은 여러 트랜잭션이 동시에 실행될때, 각 트랜잭션은 서로에게 영향을 주지 않고 독립적으로 실행되어야 함을 의미합니다.<br>
지속성(Durability)는 트랜잭션이 성공적으로 완료된 후, 그 결과가 데이터베이스에 영구적으로 저장되어야 한다는 것을 의미합니다.(장애나 오류가 나더라도)<br>
</details>

<details markdown = "1">
<summary>트랜잭션의 상태는 어떤 것들이 있을까요?</summary>
우선 Active는 트랜잭션이 실행 중인 상태, Fail은 트랜잭션 실행에 오류가 발생해 중단된 상태를 의미합니다.<br>
Aborted는 트랜잭션이 비정상적으로 종료되어 롤백을 수행하는 상태이고, Partitially Commit은 트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태를 의미합니다.<br>
마지막으로 Committed 상태는 트랜잭션이 성공적으로 종료되어 커밋 연산을 실행한 후의 상태를 뜻합니다.<br>
</details>

<details markdown = "1">
<summary>트랜잭션 격리 수준들에 대해 설명해주세요.</summary>
동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것을 트랜잭션의 격리 수준이라고 말합니다. 간단히 표현하자면, 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할 지 말지를 결정하는 것 입니다.<br>
Read Uncomitted(dirty read 발생)는 가장 낮은 격리 수준으로, 한 트랜잭션에서의 변경 내용이 아직 커밋되지 않았더라도, 다른 트랜잭션에서 그 변경내용을 조회할 수 있습니다.<br>
Read Committed(non-repeatable-read 발생)는 한 트랜잭션에서의 변경 내용이 커밋된 후에만, 다른 트랜잭션에서 그 변경 내용을 조회할 수 있습니다.(대부분의 RDBMS)<br>
Repeatable Read(phantom Read)는 트랜잭션 동안 동일한 쿼리를 여러번 실행하더라도, 조회하는 내용이 항상 동일함을 보장하는 격리수준입니다.<br>
Serializable은 여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없는 격리수준입니다.<br>
<br><br>
참고<br>
Dirty Read란 한 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 변경을 읽는것을 말합니다.(롤백될 데이터를 읽을수도 있음)<br>
Non Repeatable Read는 한 트랜잭션 내에서 같은 쿼리를 두번 수행했을때, 두 쿼리의 결과가 서로 다른것을 말합니다.(다른 트랜잭션이 수정 또는 삭제한 경우)<br>
Phantom Read는 한 트랜잭션내에서 같은 쿼리를 두번수행했을 때, 처음과 다음 조회 사이에 새로운 데이터 항목이 삽입되거나 삭제되어 결과의 행 수가 변경되는 현상을 의미합니다.<br>
</details>

<details markdown = "1">
<summary>트랜잭션 연산 중, Commit과 Rollback에 대해 설명해주세요.</summary>
Commit 연산은 트랜잭션의 모든 변경 사항을 데이터베이스에 영구적으로 저장하는 연산이고(커밋 이후 취소 불가), 롤백은 트랜잭션의 변경 사항을 취소하고, 데이터베이스를 트랜잭션이 시작되기 전의 상태로 되돌리는 연산입니다.<br>
<br>
이 연산들을 통해 트랜잭션의 원자성을 보장하고, 데이터의 무결성과 일관성을 유지할 수 있음.<br>
</details>

<details markdown = "1">
<summary>동시성 제어에 대해 설명해주세요.</summary>
동시성 제어는 동시에 여러 트랜잭션이 수행될 때, 트랜잭션들이 DB의 일관성을 파괴하지 않도록 트랜잭션 간의 상호작용을 제어하는 것을 의미합니다.<br>
</details>

<details markdown = "1">
<summary>동시성 제어 방법들에 대해 설명해주세요.</summary>

동시성 제어 방법에는 크게 `락킹`, `타임스탬프`, `MVCC(Multiversion Concurrency Control)`등이 있습니다.<br><br>
락킹은 데이터에 잠금을 걸어 다른 트랜잭션이 해당 항목에 접근하는 것을 제한하는 것으로, 공유락과 베타적락이 있습니다.<br>
공유락은 데이터를 여러 트랜잭션들이 동시에 읽을 수 있게 해주지만, 변경은 허용하지 않습니다.<br>
베타적락은 데이터 항목에 대한 모든 접근을 제한해서, 락을 소유한 트랜잭션 만이 해당 데이터 항목을 읽거나 수정할 수 있습니다.<br>
<br>
타임스탬프 방식은 각 트랜잭션에 유일한 타임스탬프를 부여하여 트랜잭션의 우선순위를 결정합니다. 데이터를 접근할 때 해당 데이터의 타임스탬프와 트랜잭션의 타임스탬프를 비교하여 동시성을 제어합니다.<br>
<br>
MVCC는 데이터의 여러 버전을 유지하여 동시성을 제어하는 방법입니다.<br>
MVCC에서 데이터에 접근하는 사용자는 접근한 시점에 데이터베이스의 snapshot을 읽습니다. 이 snapshot 데이터에 대한 변경이 커밋되기 전엔, 변경사항을 다른 데이터베이스 사용자가 볼 수 없습니다.<br>
이후 사용자가 수정을 하면 이전의 데이터를 덮어씌우는것이 아니라 새로운 버전의 데이터를 UNDO영역에 생성합니다.<br>
이때 이전 버전의 데이터와 비교해서 변경된 내용을 기록하게 되고, 이로 인해 하나의 데이터에 대한 여러 버전의 데이터가 존재하게 됩니다.<br>
</details>

<details markdown = "1">
<summary>DB Lock에 대해 설명해주세요.</summary>
DB Lock은 트랜잭션 처리의 순차성을 보장하기 위한 방법으로, 데이터에 접근하기 전에 Lock을 요청해서 Lock이 허락되면 해당 데이터에 접근할 수 있도록 하는 기법입니다.<br>
<br>
비관적락(충돌이 일어날거라 가정)은 트랜잭션이 데이터에 접근하기 전에 해당 데이터에 대한 락을 얻어와 다른 트랜잭션의 동시 접근을 제어하는 방식으로, 공유락과 베타락이 존재합니다.<br>
공유락은 사용중인 데이터를 다른 트랜잭션이 읽는것은 허용하나 쓰기는 허용하지 않는 방식이고, 베타락의 경우엔 읽기 쓰기 둘다를 허용하지 않는 방식입니다.<br>
<br>
낙관적락(Application Level)은 데이터 갱신 시 충돌이 발생하지 않을 것이라 가정하는 방식으로, 초기 데이터 접근 시 락을 걸지 않고, 실제 데이터 변경 시점에 충돌 여부를 검사하게 됩니다.<br>
각 레코드에 버전 번호나 타임스탬프를 추가해서, 데이터가 변경될 때 마다 이 값을 증가시킵니다. 이후 트랜잭션이 커밋 시점에 원래의 버전 번호나 타임스탬프와 현재 값을 비교하여 변경이 있었는지 확인하게 됩니다.<br>
이때 만약 다른 트랜잭션에 의해 값이 변경되었다면, 충돌을 감지하게 되고, 이에 따른 조치(롤백)를 취하게 됩니다.<br>
<br>
꼬리질문 - 어떠한 경우에 낙관적락을 사용하고, 어떠한 경우 비관적락을 사용하나요?<br>
<br>
낙관적 락은 데이터 충돌의 빈도가 낮고, 높은 동시성이 요구될 때 적합합니다. 이는 락에 의한 대기 시간 없이 트랜잭션을 처리할 수 있기 때문입니다.<br>
반면, 비관적락은 데이터 충돌의 빈도가 높거나 트랜잭션의 안정성이 중요한 경우에 유리합니다.<br>
트랜잭션이 데이터에 접근하면서 바로 해당 데이터를 잠그므로, 다른 트랜잭션이 동시에 접근하는 것을 방지하게 됩니다.이로 인해 데이터의 동시 변경을 막아서 충돌을 미연에 방지할 수 있고, 충돌로 인한 롤백이나 재처리와 같은 추가적인 비용을 줄일 수 있습니다<br>
</details>

<details markdown = "1">
<summary>갱신 분실 문제가 무엇인지 아시나요?</summary>
갱신 분실이란, 한 트랜잭션에서의 데이터 변경이 다른 트랜잭션에 의해 덮어쓰여져서 사라지는 현상을 말합니다.<br>
<br>
예시<br>
예를 들어, 두 트랜잭션이 동일한 계좌의 잔액을 동시에 업데이트하려고 하는 경우를 생각해보면, 한 트랜잭션에서 100달러를 추가하고, 다른 트랜잭션에서 50달러를 추가하려 할 때, 최종적으로는 150달러가 추가되어야 합니다. 그러나 갱신 분실 문제가 발생하면, 한 트랜잭션의 변경이 다른 트랜잭션에 의해 덮어쓰여져서, 예상했던 150달러가 아닌 100달러나 50달러만 추가될 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>무결성이 무엇인지, 무결성 제약 조건이 무엇인지 설명해주세요.</summary>
무결성은 데이터베이스에서 데이터의 정확성, 일관성, 그리고 신뢰성을 보장하기 위한 특성을 의미합니다.<br>
개체 무결성은 기본키 값이 중복되거나 NULL이 되어서는 안된다는 제약 조건이고, 참조 무결성은 외래키 값이 NULL이거나 참조 대상 테이블의 기본 키 값 중 하나와 일치해야 한다는 제약 조건입니다.<br>
</details>

<details markdown = "1">
<summary>JOIN 연산이 무엇인지 설명해주세요.</summary>
조인은 두개 이상의 테이블에서 관련 있는 정보를 결합하여 하나의 통합된 결과 집합을 생성하기 위해 사용됩니다.(적어도 하나의 칼럼을 공유하고 있어야 사용 가능)<br>
<br>
꼬리질문 - JOIN 연산 종류에 대해 설명해주세요.<br>
<br>
INNER JOIN은  양쪽테이블에 모두 내용이 있는 것만 조인되는 방식입니다.<br>
LEFT OUTER JOIN은 왼쪽 테이블의 모든 행과 이에 해당하는 오른쪽 테이블에서의 행을 반환하고, RIGHT OUTER JOIN은 오른쪽 테이블의 모든 행과 이에 해당하는 왼쪽 테이블에서의 행을 반환합니다.(일치하는 행이 없는 경우엔 해당 행은 NULL)<br>
CORSS JOIN은 모든 경우의 수를 출력해주는 방식이고, FULL JOIN은 두 테이블의 모든 행을 반환하는 방식으로 한쪽 테이블에만 일치하는 행이 있는 경우, 다른 테이블의 해당 부분은 NULL로 표시됩니다.<br>
<br>
꼬리질문 - INNER JOIN과 OUTER JOIN의 차이에 대해 설명해주세요.<br>
INNER JOIN은 두테이블에서 지정된 조건에 일치하는 행만 반환하는 반면, OUTER JOIN은 일치하지 않는 행(NULL로 채워짐)도 포함하여 보다 넓은 범위의 결과를 반환합니다.<br>
<br>
참고 - GROUP BY 는 GROUP BY 명령어를 통해 특정 컬럼을 기준으로 연산한 결과를 집계 키로 정의하여 그룹을 짓는 역할을 합니다.(COUNT, SUM, AVG, MAX, MIN, DISTINCT)<br>
</details>

<details markdown = "1">
<summary>DELETE, TRUNCATE, DROP의 차이에 대해 설명해주세요.</summary>
DELETE는 조건을 지정하여 특정 행만 삭제하는 명령어이고, TRUNCATE는 테이블의 모든 행을 제거하는 명령어 입니다.<br>
DROP은 테이블 자체를 데이터베이스에서 완전히 제거하는 명령어 입니다.<br>
</details>

<details markdown = "1">
<summary>트리거란 무엇이죠?.</summary>
트리거는 특정 테이블에 INSERT, DELETE, UPDATE와 같은 DML이 수행되었을때, 데이터베이스에서 자동으로 동작하도록 작성된 프로그램(메서드 형식의 쿼리)로, 사용자가 직접 호출하지 않고 DB에서 자동적으로 호출된다는 특징이 있습니다.<br>
<br>
DML이 실행되고, 자동으로 정의된 프로시저가 실행됩니다.<br>
(프로시저 : 쿼리문을 마치 하나의 메서드 형식으로 만들고 어떤 동작을 일괄적으로 처리하는 용도)<br>
<br>
꼬리질문 - 어떤 경우 트리거를 사용하는 것이 좋나요?<br>
예를 들어, 이커머스 플랫폼에서 수많은 주문이 실시간으로 발생할 때, 각 주문이 데이터베이스에 기록될 때마다 트리거를 사용하여 판매 집계 테이블을 업데이트 할 수 있습니다. 주문이 발생할 때마다 트리거가 실행되어 해당 상품의 판매 수량과 총액을 증가시키는 방식입니다. 이렇게 구성하면 별도의 집계 작업 없이 실시간으로 판매 현황을 조회할 수 있게 됩니다<br>
<br>
</details>

<details markdown = "1">
<summary>DML, DDL, DCL이 각각 무엇인지 설명해주세요.</summary>
DDL은 데이터베이스의 스키마나 구조를 정의하거나 변경하는 데(수정, 삭제) 사용되는 언어로 CREATE, ALTER, DROP, TRUNCATE 가 있습니다.<br>
DML은 데이터를 검색, 삽입, 수정, 삭제 하기 위한 언어로 SELECT, INSERT, UPDATE, DELETE 가 있습니다.<br>
DCL(데이터 제어어)는 데이터베이스의 접근 권한과 같은 데이터의 보안 및 무결성을 다루는 데 사용되는 언어로 COMMIT, ROLLBACK, GRANT, REVOKE 등이 있습니다.<br> 
</details>

<details markdown = "1">
<summary>인덱스란 무엇인가요?</summary>
추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조입니다.<br>
인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 검색하는데 빠른 장점을 가지지만, 새로운 값을 추가 삭제 수정하는 경우엔 인덱스 또한 업데이트 해야 하므로 성능이 저하될수 있고, 추가적인 저장공간이 필요합니다.<br>
<br>
참고<br>
칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 정의하고 일반적으로 B+트리 자료 구조 사용.
</details>

<details markdown = "1">
<summary>인덱스의 종류엔 무엇이 있나요???</summary>
인덱스에는 Clustered 인덱스와 Non-Clustered 인덱스가 있습니다.<br>
Clustered인덱스는 인덱스로 지정한 칼럼을 기준으로 물리적인 순서를 유지하도록 하는 방식입니다.<br>
한 테이블의 하나만 존재할 수 있고, 이를 통해 데이터 검색을 빠르게 진행할 수 있습니다.<br>
Non-Clustered 인덱스는 데이터 자체가 아닌 데이터의 위치에 대한 포인터를 저장하고 있는 인덱스입니다.<br>
클러스터 인덱스와는 달리 실제 데이터의 물리적 저장 위치와 논리적인 순서가 동일하지 않고, 한 테이블에 여러 개의 논클러스터 인덱스를 가질 수 있으며, 실제 데이터에 접근하기 전에 해당 포인터를 통해 레코드의 위치를 찾아가야 합니다.<br>
<br>
참고<br>
Clusterd의 경우 테이블 레코드가 인덱스 키에 따라 정렬되기에 검색시 빠른 속도 보장<br>
Non-Clustered 인덱스를 사용하여 데이터를 검색할 때는 먼저 인덱스를 검색하여 해당 데이터의 물리적 위치(포인터)를 찾고, 그 위치를 기반으로 실제 데이터에 접근하는 과정이 필요합니다.<br>
Non-Clustered 인덱스는 원본 데이터의 물리적인 구조와 독립적이므로, 데이터의 추가나 수정이 일어났을 때 Clustered 인덱스에 비해 리밸런싱(재정렬) 비용이 상대적으로 적습니다.<br>
<br>
인덱스의 장단점<br>
테이블을 검색하는 속도가 향상됨(인덱스에 의해 데이터가 정렬된 형태를 갖기에, 풀 테이블 스캔을 할 필요가 없음. order by나 max/min도 빠르게 실행가능)<br>
하지만 인덱스를 관리하기 위한 추가 작업및 공간이 필요하고 잘못 사용하는 경우 오히려 검색 성능이 저하됨<br>
<br>
추가 작업 예시<br>
INSERT : 새로운 데이터에 대한 인덱스를 추가<br>
DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행<br>
UPDATE : 기존의 인덱스를 사용하지 않음 처리, 갱신된 데이터에 대한 인덱스 추가<br>
데이터의 인덱스를 제거하는 것이 아니라 '사용하지 않음'으로 처리하고 남겨두기 때문에 수정 작업이 많은 경우 실제 데이터에 비해 인덱스가 과도하게 커지는 문제점이 발생할 수 있다. 별도의 메모리 공간에 저장되기 때문에 추가 저장 공간이 많이 필요하게 된다. <br>
</details>

<details markdown = "1">
<summary>인덱스는 어떻게 생성할 수 있나요?</summary>
Created Index문을 사용하면 보조 인덱스가 생성됩니다.<br>
테이블 생성시에 제약 조건에 Primary Key를 걸면 클러스터형 인덱스, Unique를 사용하면 보조 인덱스(non-clustered)가 생성됩니다.<br>
<br>
참고<br>
유니크에 Not Null까지 걸면 클러스터형 인덱스로 지정됨.<br>
</details>

<details markdown = "1">
<summary>인덱스의 자료구조에 대해 설명해주세요.</summary>
인덱스는 기본적으로 B+Tree를 이용하여 구현합니다.<br>
이는 트리 구조로 되어있어, 루트 노드에서 시작하여 원하는 값을 가진 리프노드로 찾아 내려가고, 각 노드에는 인덱스 키 값과 참조가 저장되어 있어 검색하고자 하는 값과 비교하며 탐색을 진행합니다.<br> 
이를 통해 전체 데이터를 풀 스캔하지 않아도 원하는 데이터를 효율적으로 찾아낼수 있다는 장점이 있습니다.<br>
하지만 B+Tree 인덱스는 DML 작업(삽입, 수정, 삭제) 시 페이지 분할 등의 연산이 일어날 수 있어 성능 저하가 발생할 수 있습니다.(SELECT가 빠름)<br>
<br>
참고<br>
해시테이블도 인덱스 자료구조 중 하나로 알려져 있지만, 일반적인 RDBMS에서의 인덱스로는 적합하지 않습니다. 해시테이블은 키 값을 해싱하여 저장하기 때문에 범위 검색이나 특정 문자로 시작하는 값의 검색 등이 불가능합니다. 또한, SQL 쿼리에서의 부등호와 같은 연산을 처리하는 것에 해시테이블은 제한적입니다.<br>
B트리는 각 노드에 키와 값이 함께 저장되며, 내부 노드와 리프 노드 모두 데이터를 저장할 수 있습니다.<br>
B+트리는 리프 노드에만 실제 데이터가 저장되고, 내부 노드는 키 값만을 가집니다. 또한, 리프 노드 간에는 서로 연결된 링크가 있어 순차 접근이 빠릅니다.<br>
B+트리는 하나의 노드에 더 많은 Key를 담을 수 있도록 하여 B-트리에 비해 B+트리의 높이가 더욱 낮아지게 됩니다.<br>
B+트리에서 데이터 삭제는 리프 노드에서만 이루어지기 때문에 처리 과정이 간단하고 모든 리프 노드가 동일한 높이에 있기 때문에 모든 검색의 성능이 동일합니다.<br>
B+트리의 리프 노드들은 연결 리스트처럼 서로 연결되어 있습니다. 즉, 한 리프 노드의 끝에 도달하면 다음 리프 노드로 쉽게 이동할 수 있는 포인터(주소)가 있습니다<br>
이러한 구조의 장점은 범위 검색을 할 때 특히 나타납니다. 예를 들어, 50부터 70까지의 값을 검색한다고 가정해보겠습니다. 우리는 50이 있는 리프 노드에 먼저 접근합니다. 이후, 연결된 포인터를 따라가면서 70까지의 모든 값을 순차적으로 방문하게 됩니다.<br>
다시 말해서, 50이 있는 리프 노드를 찾기만 하면, 그 노드로부터 시작해서 연결된 노드들을 통해 70까지의 값을 쉽게 찾아낼 수 있습니다. 이러한 방식으로 B+트리는 범위 검색을 효율적으로 처리할 수 있습니다.<br>
</details>






















