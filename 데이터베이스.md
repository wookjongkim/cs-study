<details markdown = "1">
<summary>DBMS가 무엇인지와 왜 사용하는지 말해주세요.</summary>
DBMS(Database Management System)은 데이터베이스 관리 시스템으로, 응용 프로그램들이 DB를 공유하며 사용할 수 있는 환경을 제공합니다.<br>
기존 파일 시스템의 데이터 종속이나 중복, 무결성 훼손, 동시 접근의 문제 발생 등을 해결하기 위해 사용합니다.
</details>

<details markdown = "1">
<summary>DB를 사용하는 이유가 무엇이죠?</summary>

- 파일시스템의 데이터 중복, 비일관성, 검색 등의 문제를 해결하기 위해 사용
- 파일 시스템이 OS마다 다를 수 있기 때문에 OS에 종속적인 파일시스템을 이용하는 것은 프로그램의 확장성을 해침
</details>

<details markdown = "1">
<summary>스키마란 무엇이죠?</summary>
데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터 집합을 의미합니다.<br>
DB에서 데이터 개체, 속성, 관계를 형식언어로 정의한 구조로, DB 사용자가 자료를 저장, 조회, 삭제, 변경할때 DBMS는 자신이 생성한 데이터베이스 스키마를 참조해 명령을 수행하게 됩니다.<br>
</details>

<details markdown = "1">
<summary>뷰가 무엇인지 설명해주시고 장점과 단점이 무엇인지 설명해주세요.</summary>
뷰는 DB에 존재하는 가상 테이블이며, 실제 테이블처럼 행과 열을 가지고 있지만 실제로 데이터를 저장하진 않습니다.<br>
뷰를 사용하면 특정 사용자에게 테이블 전체가 아닌 필요한 칼럼만 보여줄 수 있고, 복잡한 쿼리를 단순화해서 사용하고 재사용할 수 있다는 장점이 있습니다.<br>
그러나 한번 정의된 뷰는 변경할수 없고, 원래 테이블의 내용을 직접 수정해야 합니다.<br>
<br>
참고 - 실제 데이터를 저장하지 않기 때문에 경우에 따라 다수의 쿼리가 발생하여 성능 이슈가 생길 수 있음, 인덱스 가질 수 없음
</details>

<details markdown = "1">
<summary>DB에서 사용하는 '키'에 대해 설명하고, 키의 종류에 대해 설명이 가능할까요?</summary>
키란 데이터베이스 내의 레코드나 튜플을 고유하게 식별하거나 접근할때 사용됩니다.<br>
슈퍼키는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로 유일성은 만족하지만, 최소성은 만족하지 못합니다.<br>
후보키는 기본 키가 될수 있는 후보가 되는 키들을 의미하고, 슈퍼키 중에서 최소성을 만족하는 키를 의미합니다.(즉 유일성 최소성 둘다 만족)<br>
기본키는 후보키 중에서 선택된 키로, 해당 릴레이션에서 튜플을 유일하게 식별할 수 있습니다.(null 및 중복 허용 X)<br>
대체키는 기본키로 선택되지 않은 나머지 후보키들을 의미하고, 복합키는 두개 이상의 속성으로 구성된 키입니다.<br>
외래키는 한 테이블의 키 중에서 다른 테이블의 레코드를 유일하게 식별할 수 있는 키를 의미합니다.<br>
</details>

<details markdown = "1">
<summary>트랜잭션이 무엇인지 설명해주세요.</summary>
데이터베이스의 상태를 변화시키는 하나의 논리적 작업 단위를 의미합니다.<br>
논리적인 작업의 쿼리 개수와 관계 없이 트랜잭션으로 묶어놓은 작업 단위 전체가 모두 적용되거나 아무것도 적용되지 않음을 보장합니다.<br>
<br>
꼬리질문1 - 트랜잭션의 특징은 무엇이 있을까요?<br>
트랜잭션의 특징은 앞글자를 따서 ACID라고 부릅니다.<br>
원자성(Atomicity)은 트랜잭션을 구성하는 연산 전체가 모두 정상적으로 실행되거나 모두 취소되어야 한다는 특성입니다.<br>
일관성(Consistency)은 트랜잭션이 실행되기 전과 후에 데이터베이스가 일관된 상태를 유지해야 한다는 것을 의미합니다.<br>
고립성(Isolation)은 여러 트랜잭션이 동시에 실행될때, 각 트랜잭션은 서로에게 영향을 주지 않고 독립적으로 실행되어야 함을 의미합니다.<br>
지속성(Durability)는 트랜잭션이 성공적으로 완료된 후, 그 결과가 데이터베이스에 영구적으로 저장되어야 한다는 것을 의미합니다.(장애나 오류가 나더라도)<br>
</details>

<details markdown = "1">
<summary>트랜잭션의 상태는 어떤 것들이 있을까요?</summary>
우선 Active는 트랜잭션이 실행 중인 상태, Fail은 트랜잭션 실행에 오류가 발생해 중단된 상태를 의미합니다.<br>
Aborted는 트랜잭션이 비정상적으로 종료되어 롤백을 수행하는 상태이고, Partitially Commit은 트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태를 의미합니다.<br>
마지막으로 Committed 상태는 트랜잭션이 성공적으로 종료되어 커밋 연산을 실행한 후의 상태를 뜻합니다.<br>
</details>

<details markdown = "1">
<summary>트랜잭션 격리 수준들에 대해 설명해주세요.</summary>
동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것을 트랜잭션의 격리 수준이라고 말합니다. 간단히 표현하자면, 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할 지 말지를 결정하는 것 입니다.<br>
Read Uncomitted(dirty read 발생)는 가장 낮은 격리 수준으로, 한 트랜잭션에서의 변경 내용이 아직 커밋되지 않았더라도, 다른 트랜잭션에서 그 변경내용을 조회할 수 있습니다.<br>
Read Committed(non-repeatable-read 발생)는 한 트랜잭션에서의 변경 내용이 커밋된 후에만, 다른 트랜잭션에서 그 변경 내용을 조회할 수 있습니다.(대부분의 RDBMS)<br>
Repeatable Read(phantom Read)는 트랜잭션 동안 동일한 쿼리를 여러번 실행하더라도, 조회하는 내용이 항상 동일함을 보장하는 격리수준입니다.<br>
Serializable은 여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없는 격리수준입니다.<br>
<br><br>
참고<br>
Dirty Read란 한 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 변경을 읽는것을 말합니다.(롤백될 데이터를 읽을수도 있음)<br>
Non Repeatable Read는 한 트랜잭션 내에서 같은 쿼리를 두번 수행했을때, 두 쿼리의 결과가 서로 다른것을 말합니다.(다른 트랜잭션이 수정 또는 삭제한 경우)<br>
Phantom Read는 한 트랜잭션내에서 같은 쿼리를 두번수행했을 때, 처음과 다음 조회 사이에 새로운 데이터 항목이 삽입되거나 삭제되어 결과의 행 수가 변경되는 현상을 의미합니다.<br>
</details>

<details markdown = "1">
<summary>트랜잭션 연산 중, Commit과 Rollback에 대해 설명해주세요.</summary>
Commit 연산은 트랜잭션의 모든 변경 사항을 데이터베이스에 영구적으로 저장하는 연산이고(커밋 이후 취소 불가), 롤백은 트랜잭션의 변경 사항을 취소하고, 데이터베이스를 트랜잭션이 시작되기 전의 상태로 되돌리는 연산입니다.<br>
<br>
이 연산들을 통해 트랜잭션의 원자성을 보장하고, 데이터의 무결성과 일관성을 유지할 수 있음.<br>
</details>

<details markdown = "1">
<summary>동시성 제어에 대해 설명해주세요.</summary>
동시성 제어는 동시에 여러 트랜잭션이 수행될 때, 트랜잭션들이 DB의 일관성을 파괴하지 않도록 트랜잭션 간의 상호작용을 제어하는 것을 의미합니다.<br>
</details>

<details markdown = "1">
<summary>동시성 제어 방법들에 대해 설명해주세요.</summary>

동시성 제어 방법에는 크게 `락킹`, `타임스탬프`, `MVCC(Multiversion Concurrency Control)`등이 있습니다.<br><br>
락킹은 데이터에 잠금을 걸어 다른 트랜잭션이 해당 항목에 접근하는 것을 제한하는 것으로, 공유락과 베타적락이 있습니다.<br>
공유락은 데이터를 여러 트랜잭션들이 동시에 읽을 수 있게 해주지만, 변경은 허용하지 않습니다.<br>
베타적락은 데이터 항목에 대한 모든 접근을 제한해서, 락을 소유한 트랜잭션 만이 해당 데이터 항목을 읽거나 수정할 수 있습니다.<br>
<br>
타임스탬프 방식은 각 트랜잭션에 유일한 타임스탬프를 부여하여 트랜잭션의 우선순위를 결정합니다. 데이터를 접근할 때 해당 데이터의 타임스탬프와 트랜잭션의 타임스탬프를 비교하여 동시성을 제어합니다.<br>
<br>
MVCC는 데이터의 여러 버전을 유지하여 동시성을 제어하는 방법입니다.<br>
MVCC에서 데이터에 접근하는 사용자는 접근한 시점에 데이터베이스의 snapshot을 읽습니다. 이 snapshot 데이터에 대한 변경이 커밋되기 전엔, 변경사항을 다른 데이터베이스 사용자가 볼 수 없습니다.<br>
이후 사용자가 수정을 하면 이전의 데이터를 덮어씌우는것이 아니라 새로운 버전의 데이터를 UNDO영역에 생성합니다.<br>
이때 이전 버전의 데이터와 비교해서 변경된 내용을 기록하게 되고, 이로 인해 하나의 데이터에 대한 여러 버전의 데이터가 존재하게 됩니다.<br>
</details>

<details markdown = "1">
<summary>DB Lock에 대해 설명해주세요.</summary>
DB Lock은 트랜잭션 처리의 순차성을 보장하기 위한 방법으로, 데이터에 접근하기 전에 Lock을 요청해서 Lock이 허락되면 해당 데이터에 접근할 수 있도록 하는 기법입니다.<br>
<br>
비관적락(충돌이 일어날거라 가정)은 트랜잭션이 데이터에 접근하기 전에 해당 데이터에 대한 락을 얻어와 다른 트랜잭션의 동시 접근을 제어하는 방식으로, 공유락과 베타락이 존재합니다.<br>
공유락은 사용중인 데이터를 다른 트랜잭션이 읽는것은 허용하나 쓰기는 허용하지 않는 방식이고, 베타락의 경우엔 읽기 쓰기 둘다를 허용하지 않는 방식입니다.<br>
<br>
낙관적락(Application Level)은 데이터 갱신 시 충돌이 발생하지 않을 것이라 가정하는 방식으로, 초기 데이터 접근 시 락을 걸지 않고, 실제 데이터 변경 시점에 충돌 여부를 검사하게 됩니다.<br>
각 레코드에 버전 번호나 타임스탬프를 추가해서, 데이터가 변경될 때 마다 이 값을 증가시킵니다. 이후 트랜잭션이 커밋 시점에 원래의 버전 번호나 타임스탬프와 현재 값을 비교하여 변경이 있었는지 확인하게 됩나.<br>
이때 만약 다른 트랜잭션에 의해 값이 변경되었다면, 충돌을 감지하게 되고, 이에 따른 조치(롤백)를 취하게 됩니다.<br>
<br>

</details>













