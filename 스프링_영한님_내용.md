<details markdown = "1">
<summary>클라이언트가 웹 브라우저에서 특정 URL로 요청을 보냈을때, 이 요청이 내장 웹서버를 거쳐 스프링 MVC 프레임웤의 컨트롤러에 도달하고 최종적으로 뷰를 통해 클라이언트에게 응답되는 과정을 설명해주세요.</summary>
<br>
클라이언트가 웹 브라우저에서 특정 URL로 요청을 보내면, 이 요청은 내장 웹 서버를 통해 스프링 애플리케이션에 도달합니다.<br>
내장 웹 서버는 이 요청을 분석하고, 해당 URL과 매핑된 컨트롤러의 메서드를 호출합니다.<br>
이때 메서드는 스프링 프레임워크가 생성한 Model 객체를 인자로 받아, 필요한 데이터를 Model에 저장합니다.<br>
이때 Model 객체는 컨트롤러와 뷰 사이에서 데이터를 주고받는 매개체의 역할을 합니다.<br>
메서드가 뷰의 이름을 문자열로 반환하면, ViewResolver는 기본 설정 디렉토리에서 반환된 문자열에 해당하는 파일을 찾습니다.<br>
<br>
찾아진 뷰 파일은 템플릿 엔진에 의해 렌더링 되며, 이 과정에서 Model객체에 저장된 데이터를 사용하여 동적인 웹 페이지를 생성합니다.<br>
최종적으로 생성된 웹 페이지는 클라이언트에게 응답으로 전달되어, 웹 브라우저에 표시됩니다.<br>
</details>

<details markdown = "1">
<summary>@Responsebody 어노테이션의 역할을 무엇인가요?</summary>
<br>
@ResponseBody 어노테이션은 컨트롤러의 메서드가 반환하는 결과를 HTTP 응답 본문에 직접 작성하는데 사용합니다.<br>
일반적으로 이 어노테이션은 JSON 형태의 데이터를 반환하는 Restful 웹 서비스에서 사용합니다.<br>
<br>
참고 - 이 애너테이션이 없다면 뷰 리졸버한테 던져줌
</details>

<details markdown = "1">
<summary>스프링에서는 어떻게 객체를 JSON으로 변환하나요?</summary>
<br>
스프링에서는 HttpMessageConverter를 사용하여 객체를 JSON으로 변환합니다. 컨트롤러에서 반환한 객체가 있다면, 기본 정책은 이 객체를 JSON으로 변환하여 HTTP 응답 본문에 작성하는 것입니다.<br>
이때 클라이언트의 HTTP Accept 헤더와 서버의 컨트롤러 반환 타입 정보 둘을 조합해서 HttpMessageConverter가 선택됩니다.<br>
<br>
참고 - 단순 문자면 StringConverter가 동작하고 객체인 경우엔 jsonConverter가 동작
</details>

<details markdown = "1">
<summary>@Component에 대해 설명해주세요</summary>
<br>
해당 클래스가 Spring Bean임을 나타내는 어노테이션입니다. 이 클래스는 Spring의 컴포넌트 스캐너에 의해 자동으로 감지되고, ApplicationContext에 등록됩니다.<br>
</details>

<details markdown = "1">
<summary>@SpringBootTest와 @Transactional은 무엇인가요?</summary>
<br>
전자는 스프링 컨테이너와 테스트를 함께 실행하기 위한 어노테이션으로 통합 테스트시 주로 사용<br>
후자 어노테이션 사용시 테스트 시작 전에 트랜잭션을 시작하고, 테스트 완료 후에 항상 롤백을 진행하는 어노테이션<br>
이는 데이터 조회가 아니라, 데이터 저장 및 변경시에 필요함!!!!<br>
</details>

<details markdown = "1">
<summary>스프링이란 무엇인가요???</summary>
<br>
스프링은 엔터프라이즈용 자바 애플리케이션 개발을 편하게 할 수 있게 해주는 오픈소스 애플리케이션 프레임워크입니다.<br>
<br>
참고 - 스프링이 등장하기 이전에는 EJB(Enterprise Java Bean)이라는 기술이 주로 사용되었고 이 또한 이전 기술의 단점을 보완하기 위해 등장하였습니다.<br>
하지만 여전히 불필요하게 복잡한 코드를 작성해야 했고, 이에 따라 많은 개발자들이 불필요한 코드를 걷어내고 어떻게 코드의 복잡성을 줄일지 고민한 결과 탄생하였습니다.<br>
<br>
참고 - 프레임워크란, 어떠한 목적을 쉽게 달성할 수 있도록 해당 목적과 관련된 코드의 뼈대를 미리 만들어 둔것<br>
</details>

<details markdown = "1">
<summary>스프링이 가지고 있는 특징들을 설명해주세요</summary>
<br>
스프링의 가장 큰 특징은 POJO를 지향한다는 것입니다. 여기서 POJO(Plain Object Java Object)란 순수 자바, 즉 java 및 java 스펙에 정의된 기술만 사용한다는 의미입니다.<br>
예를들어 외부 라이브러리를 import해서 라이브러리 메서드를 사용하고 있다는 객체가 있다고 가정해보겠습니다.<br>
이 객체는 순수 Java외의 외부 기술을 사용하므로, POJO가 아닙니다. 이때 이 객체가 사용하고 있는 기술이 Deprecated가 되거나, 개선된 신기술이 등장하여 기존 기술과 관련된 코드를 모드 고쳐야 한다면<br>
해당 기술을 사용하고 있는 모든 객체들의 코드를 전부 바꿔주어야만 합니다.<br>
반면 POJO는 순수 자바를 사용하여 만든 객체이기에 특정 기술이나 환경에 종속되지 않아, 보다 유연하게 변화와 확장에 대처할 수 있습니다.<br>
이러한 POJO 프로그래밍을 위해 스프링이 지원하는 기술이 IOC/DI, AOP,PSA 등이 있습니다.<br>
<br>
애플리케이션 개발 시 구현해야 할 기능들은 크게 공통 관심 사항(모든 핵심 사항에 공통으로 적용되는 관심 사항)과 핵심 관심 사항(애플리케이션의 핵심 기능과 관련된 관심사항)으로 분류됩니다.<br>
이때 AOP란 애플리케이션 전반에 걸쳐 적용되는 공통 관심사항을 핵심 관심 사항인 비즈니스 로직으로부터 분리해 내는 것을 뜻합니다.<br>
ex) 핵심 사항 예시 : 배달앱 기준 메뉴 등록 주문, 주문 변경 등, 공통 관심 사항 예시 : 로깅이나 보안과 관련된 기능을 공통적으로 적용<br>
<br>
PSA(Portable Service Abstraction , 일관된 서비스 추상화)는 특정 기술에 종속되지 않도록 서비스를 추상화하여 일관된 방식으로 사용될 수 있도록 한것을 뜻합니다.<br>
<br>
ex) PSA 예시<br>
예를들어 스프링 데이터 JPA를 사용하면 특정 데이터베이스 기술에 종속되지 않는 코드를 작성할 수 있고, 이는 다른 DB로 마이그레이션이 필요할때 유용합니다. <br>
어떤 DB를 사용하든 간에 JPA 스펙을 준수하는 DB로 마이그레이션을 하면, 대부분의 코드를 변경하지 않고도 DB를 변경할 수 있습니다.<br>
또는<br>
예를들어 MySQL을 사용하여 개발을 완료했는데 다른 디비로 바꿔야 한다면 기존의 코드를 전부 지우고 새로 작성하거나, 두 디비의 간에 사용방법이 다른 코드를 찾아서 일일히 수정해야 할 수도있습니다.<br>
하지만 스프링은 데이터베이스 접근하는 방법을 규정한 인터페이스인 JDBC를 제공해 주기에 동일한 사용방법을 유지한채로 디비를 바꿀수 있습니다.<br>
각 DB를 만든 회사들은 자신의 DB에 접근하는 드라이버를 JAVA 코드의 형태로 배포하는데, 이 드라이버에 해당하는 Java 코드의 클래스가 JDBC를 구현합니다.<br>
따라서 JDBC를 기반으로 하여 DB접근 코드를 작성해두면, 이후에 DB를 바꿔도 기존에 작성한 DB 접근 로직을 그대로 사용할 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>객체지향 프로그래밍이 무엇인가요???</summary>
<br>
객체 지향 프로그래밍(인간 중심적 프로그래밍 패러다임)이란 프로그래밍에서 필요한 데이터를 추상화시켜 상태(속성)와 행위(메서드)를 가진 객체로 만들고, 그 객체 간의 상호 작용을 통해 로직을 구성하는 방법을 의미합니다.<br>
<br>
꼬리질문1 - 장단점에는 무엇이 있죠?<br>
우선 객체들이 재사용 가능한 컴포넌트(자체로 기능을 수행할 수 있는 모듈, 보통 인터페이스로 다른 컴포넌트와 상호작용)로 설계될 수 있어, 같은 기능을 다시 구현할 필요 없이 해당 객체를 재사용하거나 상속받아 확장하여 사용할 수 있습니다.<br>
그리고 객체 단위로 코드가 구분되어 있어, 특정 기능에 문제가 발생하거나 변경이 필요할때 해당 객체만을 수정하면 되므로 유지 보수 과정을 간소화할 수 있습니다.<br>
또한 데이터는 객체 내부에 캡슐화되어, 외부에서 직접 접근할 수 없습니다. 이때 데이터 접근은 객체가 제공하는 메소드를 통해서만 가능하므로, 데이터를 안전하게 보호할 수 있습니다.<br>
하지만 설계 단계에서 상당한 시간이 걸릴수 있고 객체 간의 메세지 전달이나 상속등의 오버헤드 때문에 절차 지향 프로그래밍에 비해 처리 속도가 느립니다.<br>
또한 객체가 상태를 가지고 있기에, 이러한 상태 변경의 예측(객체 메서드에 의해 변경)이 어렵고 디버깅하기 어렵게 만들 수 있습니다.<br>
만약 특정 상태에 종속적인 경우, 그 객체는 상태에 따라 다르게 작동하므로 재사용이 어려울 수도 있습니다.<br>
<br>
절차지향 프로그래밍이란, 프로그램을 일련의 순차적인 절차 또는 단계를 따라 데이터에 작업을 수행하는 방식을 말합니다.(컴퓨터의 동작 방식과 동일)<br>
이러한 객체지향 탄생 이유 -> 코드의 유연성을 위해<br>
상태(ex: int count)가 여러 메서드에 의해서 여러 방식으로 변경될 수 있기에, 상태를 추적하고 이해하는데 어려울 수 있고<br>
멀티스레딩 환경에서 동일한 객체에 동시 접근하려할때 상태 값이 예기치 않게 변경될 수 있어 동기화 메커니즘을 필요로 합니다.<br>
그리고 클래스내에 다른 상태에 의존하고 있는 메서드를 가지고 있다면, 그 메서드는 특정 상태에 따라 다르게 동작하므로 재사용성이 어려울 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>객체지향 프로그래밍의 주요 원칙(특징)에는 무엇이 있죠??</summary>
<br>
객체지향 프로그래밍의 주요 특징에는 캡슐화, 상속, 다형성, 추상화가 있습니다.<br>
캡슐화는 데이터와 그 데이터를 처리하는 메소드를 하나의 클래스로 묶는 것을 의미합니다. 이를 통해 클래스의 내부 데이터를 외부로부터 보호하며, 클래스 사용자가 클래스의 내부 구조나 동작 방식에 대해 상세히 알 필요 없이 메소드를 사용하는 것만으로 해당 클래스를 사용할 수 있게 됩니다.<br>
상속은 한 클래스의 속성과 메소드를 다른 클래스가 물려받아 사용하는 것입니다. 상속을 통해 새로운 클래스는 기존 클래스의 특성과 메소드를 재사용할 수 있으며, 필요에 따라 특성과 메소드를 추가하거나 재정의 할 수 있습니다.<br>
클래스들 간 공유하는 속성과 기능들을 반복적으로 정의할 필요 없이 딱 한 번만 정의해두고 간편하게 재사용할 수 있어 반복적인 코드를 최소화하고 공유하는 속성과 기능에 간편하게 접근하여 사용할 수 있도록 합니다.<br>
다형성은 어떤 객체의 속성이나 기능이 그 맥락에 따라 다른 역할을 수행할수 있는 의미합니다. 예를 들어, 메소드가 같은 이름을 가지지만, 입력 매개변수에 따라 다르게 동작하는 오버로딩, 또는 같은 이름의 메소드(동물 울다 -> 강아지 멍멍, 고양이 야옹)가 슈퍼클래스와 서브클래스에서 다른 행동을 하는 오버라이딩 등이 이에 해당합니다.<br>
좀더 객체 지향적인 관점에서 다형성을 다루어보자면 상위 클래스의 타입의 참조변수로 하위 클래스의 객체를 참조할 수 있도록 하는 것입니다.<br>
추상화는 객체의 공통적인 속성과 기능을 추출하여 정의하는 것을 의미합니다. 다른 말로 표현하자면 인터페이스에는 추상 메서드나 상수를 통해서 어떤 객체가 수행해야 할 핵심적인 역할만을 규정해두고, 실제적인 구현은 해당 인터페이스를 구현하는 각각의 객체에서 하도록 프로그램을 설계하는 것입니다. 이를 통해 인터페이스에 정의한 역할을 각각의 클래스의 맥락에 맞게 구현하게 되고, 이를 통해 변경에 유연한 프로그래밍을 할 수 있습니다.<br>
<br>
참고<br>
앞서 봤었던 추상화의 연장선에서, 상속은 클래스 간 공유될 수 있는 속성과 기능들을 상위 클래스로 추상화 시켜 해당 상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용<br>
상속은 상위 클래스에서 이미 정의된 속성과 메소드를 그대로 사용하거나, 필요에 따라 변경하여 사용할 수 있습니다. 하지만 인터페이스를 통한 구현은 인터페이스에서 지정된 메소드를 반드시 구현해야 하므로, 인터페이스를 통한 구현이 더 높은 수준의 추상화를 제공합니다.<br>
<br>
다형성의 장점<br>
여러 종류의 객체를 배열로 다루는 일이 가능해짐, 그리고 객체 간의 결합도를 낮출 수 있음<br>
예를 들어, 우리가 '운송수단'이라는 인터페이스를 정의하고, '자동차', '비행기', '배'와 같은 여러 클래스가 이 인터페이스를 구현하게 한다면, 우리는 특정한 운송수단을 선택하지 않고도 '운송수단'이라는 인터페이스를 통해 다양한 종류의 운송수단을 사용할 수 있습니다.
<br>
즉, 프로그램 코드는 '운송수단'이라는 인터페이스에 의존하게 되고, 이는 프로그램 코드와 각 운송수단 클래스 간의 결합도를 낮춥니다. 이렇게 결합도를 낮추면, '자동차', '비행기', '배' 클래스 중 어떤 것이 변경되더라도 프로그램 코드를 변경할 필요가 없게 되므로 코드의 유지 보수가 쉬워집니다.<br>
</details>

<details markdown = "1">
<summary>SOLID 원칙에 대해 아시나요?</summary>
<br>
SOLID는 좋은 객체 지향 설계를 위한 5가지 원칙을 다룬 개념입니다.<br><br>
우선 단일 책임 원칙(Single Responsibility Principle)은 한 클래스가 하나의 책임만을 가지도록 하는 원칙입니다.<br> 
이때 중요한 기준을 변경이라고 보는데, 해당 클래스에 대한 변경이 있을때 다른 클래스에 파급 효과가 적다면 단일 책임을 잘 따른것이라 볼 수 있습니다.<br>
이러한 원칙을 준수하면 각 클래스가 맡은 책임이 명확해져, 한 책임의 변경이 다른 책임에 미치는 영향을 최소화 할 수 있습니다.<br>
<br>
개방 폐쇄 원칙은 소프트웨어 구성 요소가 확장에는 열려 있어야 하며, 변경에는 닫혀있어야 함을 의미합니다.<br>
즉 새로운 변경 사항이 발생했을때 직접적인 객체 수정 없이도 이를 반영할 수 있도록 설계해야 함을 의미합니다.<br>
이를 지원하기 위해 스프링에서는 DI(의존성 주입)과 제어의 역전(IOC)를 제공합니다.<br>
<br>
리스코프 치환원칙은 객체가 프로그램의 정확성을 깨지 않으면서 하위 인스턴스로 바꿀수 있어야 한다는 원칙입니다.<br>
클라이언트는 인터페이스를 구현한 객체의 내부 구현을 알지 못하므로, 객체는 인터페이스의 명세를 준수하여 구현되어야 합니다.<br>
예를들어 자동차 인터페이스에 앞으로 가는 기능을 선언했는데, 이를 뒤로 가게 구현한 것은 LSP를 위반한 예입니다. 느리더라도 앞으로 가는 기능을 제공해야 LSP를 준수한 것입니다.<br>
<br>
인터페이스 분리 원칙은 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 나음을 의미합니다.<br>
예를 들어, '전자기기'라는 인터페이스에 '켜기', '끄기', '충전하기', '인쇄하기'라는 메소드가 있다면, '스마트폰' 클래스는 '인쇄하기' 메소드를 사용하지 않을 것입니다. 이럴 때 '스마트폰'을 위한 '켜기', '끄기', '충전하기' 메소드만을 가진 인터페이스와 '인쇄하기' 메소드를 가진 인터페이스로 분리하는 것이 더 효과적일 수 있습니다. 이렇게 하면 각 클래스는 필요한 메소드만을 포함한 인터페이스에 의존하게 되므로 더 명확하고 깔끔한 설계를 할 수 있습니다.<br>
<br>
마지막으로 의존관계 역전 원칙은 프로그래머가 구체적인 것보다 추상화된 것에 의존해야 함을 의미합니다.<br>
즉, 클라이언트가 구현 객체에 직접 의존하는 것이 아니라, 클라이언트와 구현 객체 모두 인터페이스에 의존해야 합니다. 이렇게 되면 구현 객체가 변경되더라도 클라이언트에는 아무런 변화가 없게 됩니다.<br>
<br>
DIP 예시<br>
예를 들어, 회사에서 서비스를 운영하면서 MySQL에서 PostgreSQL로 데이터베이스를 바꾸려고 합니다. 이 때, 웹 애플리케이션의 각 부분이 구체적으로 MySQL에 의존하고 있다면, 이 변경은 코드의 모든 부분을 수정해야 하는 매우 큰 작업이 될 것입니다. 또한, 이러한 변경은 버그를 만들 가능성이 크기 때문에 위험성도 큽니다.<br>
하지만 만약 웹 애플리케이션의 각 부분이 데이터베이스에 직접 의존하는 대신, 데이터베이스 인터페이스(DB Interface)에 의존하도록 설계되어 있다면 이 문제는 간단히 해결될 수 있습니다.<br>
이 인터페이스는 MySQL과 PostgreSQL 모두에서 사용할 수 있는 일반적인 메소드(예: get, set, update, delete 등)를 정의합니다. 웹 애플리케이션의 나머지 부분은 이 인터페이스를 통해 데이터베이스와 상호작용하므로, 어떤 데이터베이스가 뒤에 연결되어 있더라도 그것에 영향을 받지 않습니다.<br>
따라서 MySQL에서 PostgreSQL로 데이터베이스를 바꿀 때는 단지 인터페이스를 구현하는 클래스만 바꾸면 됩니다. 웹 애플리케이션의 나머지 부분은 이 변경을 알아차리지 못하고 그대로 작동합니다. 이러한 접근 방식은 의존관계 역전 원칙을 따르는 것이며, 시스템의 유연성과 확장성을 크게 향상시킵니다.<br>
</details>












