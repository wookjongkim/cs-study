## 운영체제 관련 질문
<details markdown = "1">
<summary>운영체제란 무엇이죠?</summary>
운영체제란 컴퓨터 하드웨어와 소프트웨어 리소스를 관리하며 사용자와 컴퓨터 사이의 인터페이스 역할을 하는 시스템 소프트웨어입니다.<br>
이를 좁은 의미로 보면 커널 그 자체를 의미하고, 넓은 의미로 보면 커널과 각종 시스템 유틸리티(GUI, 시스템콜, 드라이버(하드웨어 제어하기 위한 SW 등)를 포함합니다.
<br>
꼬리질문 1 - 그렇다면 커널이란 무엇인가요??<br>
커널은 운영체제 코드 중에서도 핵심적인 부분을 나타냅니다. 커널은 하드웨어 제어 뿐만 아니라 메모리 및 프로세스 관리 등 다양한 운영체제 기능을 수행하고 부팅 이후 메모리에 <br>
항상 상주하고 있습니다.<br>
<br>
꼬리질문 2 - 운영체제의 역할은 무엇인가요?? or 왜 필요한가?
운영체제는 사용자가 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공해주고(ex: GUI, 멀티태스킹으로 작업 동시에 하는것 처럼 느끼게),<br>
컴퓨터 시스템 내의 자원(하드웨어 + 소프트웨어)을 효율적으로 관리하는 역할을 합니다.<br>
<br>
</details>

<details markdown = "1">
<summary>커널은 어떻게 구성되어있나요?</summary>
커널 또한 프로그램이기에 코드,데이터,스택으로 구성된 주소 공간을 가집니다.<br>
이때 코드 영역에는 하드웨어를 관리하기 위한 코드나 사용자에게 인터페이스를 제공하기 위한 코드, 시스템 콜 및 인터럽트 처리를 위한 코드 들을 담고있습니다.<br>
커널의 데이터 영역에는 각종 자원을 관리하기 위한 자료구조가 저장되어있으며, 여기에 PCB가 저장되어있습니다.<br>
커널의 스택 영역은 커널 모드에서 실행되는 프로세스나 함수들의 지역 변수나 리턴 주소 등을 저장하는 공간입니다.<br>
<br>
꼬리 질문1 - 커널 스택 영역과 스택 영역의 차이점이 있나요??
사용자 스택 영역은 해당 프로그램만 접근할 수 있습니다. 이에 반해 커널 스택 영역은 커널이 실행 중인 모든 프로세스에서 접근할 수 있습니다<br>
</details>



## 하드웨어 관련 질문
<details markdown = "1">
<summary>(운영체제의 or 컴퓨터 시스템의) 하드웨어는 어떻게 구성되어있을까요??</summary>
운영체제의 하드웨어는 크게 CPU, 메모리, 디스크, 입출력 장치로 구성되어 있습니다.<br>
<br>
꼬리질문 1 - 각각의 역할을 무엇인가요?<br>
CPU는 중앙 처리 장치로서, 프로그램의 연산 및 처리를 담당하는 핵심적인 역할을 합니다.<br>
메모리는 CPU가 직접 접근할 수 있는 저장 공간으로, CPU 처리를 위해 임시적으로 프로그램의 코드나 데이터 등이 저장되는 공간입니다.<br>
디스크는 메모리와 마찬가지로 데이터를 저장하는 공간입니다. 하지만 앞서 설명드린 메모리는 휘발성 기억장치인 것과 달리, 디스크는 비휘발성 기억장치이기에 한번 디스크에 저장되면 컴퓨터가 꺼지더라도 데이터가 보존됩니다.<br>
입출력장치는 사용자와 컴퓨터간의 상호작용을 가능하게 하는 장치로서, 키보드나 마우스 모니터 등이 이에 해당합니다. 이들은 사용자의 입력을 받아들이거나, 컴퓨터의 처리 결과를 사용자에게 보여주는 역할을 합니다.<br>
</details>

<details markdown = "1">
<summary>DMA(Direct Memory Access)란 무엇이죠?</summary>
DMA란 컴퓨터에서 입출력 장치와 메모리 사이의 데이터 전송을 CPU의 개입 없이 직접적으로 처리하는 기능을 뜻합니다.<br>
일반적으로, 데이터를 메모리와 입출력 장치(로컬 버퍼) 사이에 이동시키는 작업은 CPU가 담당합니다. 하지만 이런 방식은 CPU의 부하를 증가시키고, 이로 인해 CPU의 다른 중요한 작업이 지연될 수 있습니다.<br>
DMA는 이러한 문제를 해결하기 위해 설계되었습니다. DMA 컨트롤러는 CPU의 개입 없이 메모리와 입출력 장치 사이에서 데이터를 직접 이동시켜 CPU의 부하를 줄이고, CPU가 더 중요한 작업에 집중할 수 있게 해줍니다.<br>
</details>

<details markdown = "1">
<summary>CPU가 무엇인지랑 구성 요소 및 연산 처리 과정을 간단히 설명해주세요.</summary>
CPU는 중앙 처리 장치로서, 프로그램의 연산 및 처리를 담당하는 핵심적인 역할을 합니다.(메모리에 있는 명령어 해석해서 실행하는 일꾼)<br>
이러한 CPU는 제어 장치, 레지스터, 산술 논리 연산 장치로 구성되어있습니다.<br>
제어장치는 명령어를 읽고 해석하며, 데이터 처리를 위한 순서를 결정합니다.<br>
레지스터는 CPU 안에 있는 매우 빠른 임시기억 장치로 연산에 사용되는 데이터나 중간 결과를 보관하고 있습니다.<br>
산술 논리 연산 장치(ALU)는 덧셈 뺄셈과 같은 두 숫자의 산술 연산과, 논리 연산을 계산하는 디지털 회로입니다.<br>
연산 처리 과정에서 우선 제어장치가 메모리와 레지스터에 계산할 값을 로드합니다.<br>
이후 제어장치가 레지스터에 있는 값을 계산하라고 산술논리연산 장치에 명령 한 후, 계산된 값을 다시 레지스터에서 메모리로 계산한 값을 저장합니다.<br>
</details>

<details markdown = "1">
<summary>메모리 계층 구조에 대해 설명해주세요.</summary>
메모리 계층 구조는 레지스터, 캐시 메모리, 주기억 장치, 보조기억 장치로 나뉩니다.<br>
레지스터는 CPU 내에 위치하며, CPU가 접근할 수 있는 고속의 메모리입니다.<br>
캐시 메모리는 CPU와 직접 연결되어 있는 메모리로, 자주 사용되는 데이터를 저장합니다.(L1,L2,L3 등 계층으로 구성될 수 있음)<br>
주기억장치는 RAM을 가리키며, CPU가 필요로 하는 데이터와 프로그램을 임시적으로 저장합니다.<br>
보조 기억 장치는 대용량의 데이터를 영구적으로 저장하는 상용되며, 접근 속도는 느리지만 저장 용량이 크고 비용이 저렴합니다.<br>
</details>

<details markdown = "1">
<summary>타이머란 무엇인가요?</summary>
타이머는 정해진 시간이 지나면, 인터럽트를 발생시켜 운영체제가 CPU의 제어권을 획득할 수 있도록 하는 하드웨어입니다.<br>
이때 운영체제가 CPU 제어권을 얻으면, 현재 실행 중인 프로세스를 중지하고 다음 프로세스에게 CPU를 넘겨줍니다.<br>
</details>

## 프로세스와 스레드 관련 질문
<details markdown = "1">
<summary>프로세스란 무엇이죠?</summary>
프로세스란 운영체제에서 실행 중인 프로그램의 인스턴스로 운영체제로부터 CPU,메모리 공간 등의 시스템 자원을 할당받아 작업을 수행합니다.<br>
각 프로세스는 독립된 메모리 영역(code,data,stack,heap)을 가지며, 이 영역은 다른 프로세스로 부터 보호되어 접근 할 수 없습니다.<br>
<br>
꼬리질문 1 - 어떻게 다른 프로세스가 해당 프로세스 영역에 접근하지 못하는 것이죠??<br>
프로세스가 자신에게 할당되지 않은 메모리 영역에 접근하려고 하면 운영체제가 이를 잘못된 메모리 접근으로 판단하고 해당 프로세스를 종료하기 때문입니다.<br>
</details>

<details markdown= "1">
<summary>프로세스의 주소 공간(프로세스 or 프로그램 구조)에 대해 설명해주세요</summary>
프로세스 주소 공간이란 운영체제가 각 프로세스에게 할당하는 독립적인 메모리 영역으로 코드, 데이터, 스택, 힙 영역으로 나누어져 있습니다.<br>
코드 영역에는 프로그래머가 작성한 프로그램 함수들의 코드가 (CPU가 해석 가능한) 기계어 형태로 저장되는 영역입니다.(읽기 전용)<br>
데이터 영역에는 코드가 실행되면서 사용되는 전역 변수나 각종 데이터(정적 변수)가 저장되는 영역입니다.<br>
스택 영역은 함수 호출과 관련된 정보, 예를 들어 지역 변수나 복귀 주(함수 종료 후 제어가 돌아갈 곳)등이 저장되는 공간입니다. <br>
이때 함수 호출이 발생하면 해당 정보는 스택에 푸쉬되고, 함수가 반환되면 스택에서 팝됩니다.<br>
마지막으로 힙 영역은 프로세스가 동적으로 메모리를 할당받는 공간입니다. 즉 프로세스 실행 중에 필요 따라 메모리를 할당하거나 해제하는 영역입니다.<br>
<br>
나눈 이유 - 프로그램의 각 요소들이 수행하는 역할에 따라 필요한 메모리 영역을 제공함. 메모리 효율적 관리.<br>
영역 분리하면 메모리 접근 권한을 통해 보안을 강화 가능.
</details>

<details markdown = "1">
<summary>프로세스 상태 변화 과정을 설명해주세요.</summary>
프로세스는 다양하게 상태가 변경되며 수행됩니다. new 상태는 프로세스가 생성중인 상태를 뜻합니다(메모리 획득 승인 받지 못한 상태). 그러다 프로그램이 메모리에 올라가고 CPU를 할당받기 위해 기다리는 경우 이를 ready 상태라고 합니다.<br>
ready 상태에서 CPU를 획득하여 명령을 수행중인 상태는 running 상태라고합니다. 입출력 명령을 기다리는 동안 프로세스는 CPU를 빼앗기게 되고 CPU를 할당 받더라도 당장 명령을 수행할 수 없는 상태가 되는데, 이를 blocked(봉쇄)상태라고 합니다.<br>
운영체제는 너무 많은 프로세스가 메모리에 올라와 있으면 당장 사용하지 않는 프로세스를 통째로 디스크에 쫓아냅니다. 이렇게 통째로 디스크로 swap out된 프로세스의 상태는 suspended 상태라고 합니다. 또한, ready 상태의 프로세스가 swap out 되어서 디스크에 있는 상태를 Ready Suspend (Suspended Ready) 상태라고 하고, blocked 상태의 프로세스가 swap out된 상태를 Blocked Suspend (Suspended Blocked) 상태라고 합니다.<br>
이후 수행이 끝난 상태는 terminated 상태라고 합니다. 추가로, 운영체제가 메모리 공간이 충분해질 때, 디스크에서 메모리로 프로세스를 다시 옮기는 과정을 swap in이라고 합니다. 이 과정을 통해 프로세스는 다시 ready 상태로 돌아오게 됩니다.<br>
<br>
꼬리질문 1 - 흠.. blocked 상태와 suspended 상태의 차이가 뭐죠?<br>
Blocked 상태와 Suspended 상태의 차이는 크게 두 가지입니다.<br>
Blocked 상태는 프로세스가 메모리에 있지만 특정 이벤트(예를 들어, 입출력 작업의 완료)를 기다리고 있어 CPU를 사용할 수 없는 상태를 나타냅니다. 이와는 달리, Suspended 상태는 시스템의 메모리 부족 혹은 운영체제의 관리 정책 등에 의해 프로세스가 메모리에서 디스크로 옮겨진 상태를 의미합니다<br>
두 번째 차이점은 프로세스가 Ready 상태로 돌아가는 방법에 있습니다. Blocked 상태의 프로세스는 자신이 기다리고 있는 이벤트가 완료되면 바로 Ready 상태로 돌아갑니다. 반면에, Suspended 상태의 프로세스는 외부에서 명시적으로 Resume 명령을 받아야만 다시 Ready 상태로 돌아갈 수 있습니다<br>
<br>
Resume 명령은 일반적으로 프로세스가 Suspended 상태에서 다시 Ready 상태로 돌아가기 위해 필요한 명령을 의미<br>
유저 모드 Running -> 커널 모드 Running은 시스템콜,인터럽트, 트랩등에 의해, 이후 복귀<br>
Running -> Blocked : 입출력 요청, Blocked -> Suspended Blocked 스왑 아웃, 스왑 인, Ready -> Suspended Ready : 스왑아웃, 스왑 인<br>
block -> wait : 입출력 작업이 완료된 경우 Suspended Blocked -> Suspended Ready : 입출력 작업 완료된 경우<br>
</details>

<details markdown = "1">
<summary>프로세스는 다양한 상태가 존재하네요. 스케줄러를 통해 이를 어떻게 관리하는지 설명해주세요.</summary>
운영체제는 프로세스들을 관리하고 스케줄링 하기 위한 큐를 두고 있습니다.(커널 데이터 영역에)<br>
Ready Queue는 ready 상태의 프로세스들을 줄세우고, device queue는 device 입출력 작업을 대기하고 있는(blocked) 큐입니다.<br>
그리고 job Queue는 시스템 내의 모든 프로세스를 관리하는 큐(위 두개 다 포함하는 상위개념)입니다.<br>
각 큐에 줄서 있는 프로세스들을 관리하기 위한 스케줄러는 총 3종류로 존재합니다.<br>
장기 스케줄러는 프로세스를 ready queue에 진입시킬지를 결정합니다. 즉 프로세스의 메모리 할당에 관여합니다.<br>
중기 스케줄러는 어떤 프로세스를 스왑 아웃 시킬지 결정하고, 단기 스케줄러는 ready 상태 프로세스 중 어떤 프로세스에게 CPU를 줄지 결정합니다.<br>
<br>
중기 스케줄러 스왑 아웃 우선순위 1순위 - block 상태 프로세스, 2순위 타이머 인터럽트에 의해 ready 상태가 된 프로세스
</details>

<details markdown = "1">
<summary>PCB란 무엇인가요?</summary>
운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내(데이터 영역)의 자료 구조를 뜻합니다<br>
이러한 PCB에는 프로세스 구분자, 프로세스 상태, PC값, 메모리 관리 정보, CPU 스케줄링 정보 등을 담고있습니다.<br>
<br>
꼬리질문 1 - 위와 같은 정보들이 왜 필요한거죠??
이러한 정보들이 필요한 이유는 운영체제가 각 프로세스를 효율적으로 관리하고, 필요한 작업을 수행하기 위함입니다
예를 들어, 프로세스의 상태 정보는 프로세스가 어떤 상태에 있는지를 알려주어, 해당 프로세스에 대한 적절한 작업을 수행하게 합니다.<br>
메모리 관리 정보는 프로세스의 메모리 사용을 추적하고 관리하는데 사용되며, 이는 메모리 누수와 같은 문제를 방지하고, 메모리 사용의 효율성을 높이는 데 도움이 됩니다<br>
프로그램 카운터와 레지스터들의 정보는 프로세스가 중단된 후에도 프로세스의 실행을 재개할 수 있도록 돕습니다. 이 정보를 이용하면 프로세스의 현재 상태를 저장하고, 필요한 경우에 원래의 상태로 복원할 수 있습니다.
<br>
따라서, 이러한 정보들은 프로세스의 관리와 실행을 위해 꼭 필요한 정보들입니다.<br>
<br>
참고 - 포인터,프로그램 우선순위, 각종 레지스터 정보, 계정정보, PPID CCID 정보도 담고있음.<br>
</details>

<details markdown = "1">
<summary>Context Switching이란 무엇이고 왜 필요한것이죠??</summary>
컨텍스트 스위칭(Context Switching)은 CPU가 하나의 태스크(프로세스 혹은 스레드)에서 다른 태스크로 작업을 전환하는 과정을 말합니다. 이 과정에서 현재 실행 중인 태스크의 상태를 프로세스 제어 블록(Process Control Block, PCB)에 저장하고, 실행할 다음 태스크의 상태 값을 PCB에서 읽어와 CPU의 레지스터에 적재합니다<br>
이렇게 컨텍스트 스위칭을 통해 CPU는 I/O 작업이 실행되어 블로킹 상태에 놓인 태스크에서 다른 태스크로 전환할 수 있습니다. 이는 CPU가 I/O 작업의 대기 시간 동안 유휴 상태에 놓이는 것을 방지하고, 더 효율적으로 CPU를 활용할 수 있게 합니다<br>
또한, 컨텍스트 스위칭 덕분에 운영체제는 여러 프로세스를 동시에 처리하는 것처럼 보이게 함으로서 시분할 시스템 또는 멀티태스킹을 실현합니다<br>
그러나 이 과정은 오버헤드를 발생시키며, 이 시간 동안 CPU는 실제 작업을 수행할 수 없습니다. 그렇지만 일반적으로 이 오버헤드 시간은 I/O 작업 시간에 비해 훨씬 짧기 때문에, 컨텍스트 스위칭이 시스템의 전반적인 효율성을 향상시키는 데에 기여합니다<br>
<br>
유사질문 1 - 컨텍스트 스위칭은 주로 어떤 경우 발생하나요??
컨텍스트 스위칭은 타이머 인터럽트나, 입출력 요청 등에 의해 주로 발생합니다.<br>
실행 중인 프로세스가 할당된 시간을 모두 소비하면, 운영체제는 타이머 인터럽트를 발생시키고 CPU의 제어권을 넘겨받습니다. 운영체제는 실행 중이던 프로세스의 상태를 저장하고, 다음으로 실행할 준비 상태의 프로세스를 선택하여 그 프로세스에게 CPU의 제어권을 넘깁니다. 이를 통해 CPU는 다양한 프로세스를 공평하게 실행할 수 있게 됩니다<br>
실행 중인 프로세스가 입출력 작업을 요청하면, 해당 프로세스는 봉쇄 상태로 전환됩니다. 이때 운영체제는 준비 상태에 있는 다른 프로세스를 선택하여 CPU의 제어권을 넘깁니다. 이는 입출력 작업이 완료될 때까지 CPU가 유휴 상태에 머무르는 것을 방지하고, CPU의 활용도를 높입니다<br>
<br>
참고- 이때 준비 상태에 있는 프로세스중 어떤 프로세스에게 CPu를 할당할지 결정하고, 해당 CPU에게 제어권을 넘겨주는 과정을 디스패치라고 함.
</details>

<details markdown = "1">
<summary>프로세스는 어떻게 생성되나요?</summary>
시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만, 그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성하게 됩니다.<br>
이때 프로세스를 생성한 프로세스를 부모 프로세스, 새롭게 생성된 프로세스를 자식 프로세스라고 합니다.<br>
<br>
자식 프로세스는 부모 프로세스의 context(레지스터 상태나 Pc값들)을 그대로 복제하여 생성됨(fork() 시스템콜을 통해)<br>
이때 독자적인 작업을 시키고 싶다면 exec() 시스템 콜을 사용해야 함<br>
<br>
exit 시스템콜은 프로세스가 실행 완료했을때나, 어떤 이유로 더 이상 실행을 계속할 수 없을때 exit()을 통해 운영체제에 알림(자발적 종료), 이후 운영체제는 시스템 자원 회수하고 종료상태로 바꿈<br>
wait() 시스템콜은 부모 프로세스가 자식 프로세스 종료를 기다리기 위해 사용. 이를 통해 서로 동기화 가능<br>
</details>

<details markdown = "1">
<summary>IPC(Inter Process communication)란 무엇인가요?</summary>
IPC란 다른 프로세스간에 데이터를 주고 받을 수 있게 해주는 메커니즘입니다. 즉 독립적으로 실행되는 프로세스들 사이에 정보를 교환하게 해줍니다.<br>
이러한 IPC 메커니즘은 다양한 방식으로 구현될 수 있습니다.<br>
첫번째는 익명 파이프(PIPE)입니다. 여기서 파이프란 두 프로세스간 파이프를 연결해서 통신하는 방식으로, 이때 한 프로세스는 쓰기만 가능하고 한 프로세스는 읽기만 가능합니다.<br>
그리고 이는 한쪽 방향으로만 통신이 가능하기에 반 이중 통신이라 부르기도 합니다.(이 또한 전이중 통신위해서는 파이프 2개를 만들어야 함)<br>
<br>
두번째로 Named Pipe(FIFO) 방식이 있습니다. 앞서 설명드린 PIPE는 통신하는 프로세스가 명확할 경우(ex: 부모-자식 프로세스간) 사용하는 반면, NamedPIPE는 전혀 모르는 사이의 프로세스들의 통신에 사용합니다.<br>
하지만, 익명 PIPE와 동일하게 동시에 읽기/쓰기가 불가능 하고, 전 이중 통신을 위해서는 익명 파이프처럼 2개를 만들어야 가능합니다.<br>
<br>
메세지 큐는 프로세스 간 메세지를 주고 받는 방식으로, 일반적으로 큐 자료구조를 이용하여 구현됩니다.이때 메세지를 보내는 프로세스는 메세지 큐에 메세지를 넣고, 메세지를 받는 프로세스는 메세지 큐에서 메세지를 가져옵니다.<br><br>
공유 메모리 방식은 두개 이상의 프로세스가 동일한 물리적 메모리 공간을 공유하여 데이터를 주고 받는 방식입니다.<br>
프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당해줍니다. 이후 어떤 프로세스건 해당 메모리영역에 접근할 수 있습니다. 공유 메모리는 곧바로 메모리에 접근할 수 있기 때문에 IPC 방식 중 속도가 제일 빠릅니다(근데 동기화 고려해야).<br>
<br>
소켓(Socket)은 네트워크에서 동작하는 프로세스 간에 데이터를 교환하는 방식으로 서로 다른 시스템에 있는 프로세스들 사이에서 데이터를 주고 받을 때 적합합니다.<br>
이때 서버 프로세스는 특정 포트에서 들어오는 클라이언트 연결을 수신하기 위해 소켓을 열고 대기하고, 클라이언트 프로세스는 서버의 IP와 포트를 알고 있어야 연결을 수립할 수 있습니다.<br>
<br>
참고 - 메세지큐는 FIFO, 여러 프로세스가 동시에 큐에 접근하여 메세지를 읽고 쓸 수 있다는 것입니다. 각 프로세스는 메세지를 큐에 추가하거나 큐에서 메세지를 꺼내어 처리하며, 이 방식을 통해 여러 프로세스 간에 데이터를 공유할 수 있습니다.<br>
메세지 큐는 메모리 내에 위치하여 빠른 속도로 데이터를 전달하고, 프로세스가 종료되어도 큐에 있는 메세지는 사라지지 않습니다. 이러한 특성 때문에 메세지 큐는 서로 다른 라이프 사이클을 가진 프로세스간의 통신에 적합합니다.<br>
</details>



## 입출력 관련 질문
<details markdown = "1">
<summary>입출력이란 무엇인가요?</summary>
외부 장치로부터 필요한 외부 장치로 부터 필요한 데이터를 받아 프로그램에서 사용하는 메모리에 저장하거나, 메모리에 있는 데이터를 외부 장치로 보내는 것을 뜻합니다.<br>
<br>
</details>

<details markdown = "1">
<summary>동기식 입출력과 비동기식 입출력의 차이에 대해 아시나요?</summary>
동기식 입출력에서는 I/O 작업이 완료될 때 까지 프로세스가 대기 상태를 유지하는 반면, 비동기식 입출력에서는 I/O 작업을 요청한 후, 그 작업의 완료를 기다리지 않고 바로 다음 작업으로 넘어갑니다.<br>
동기식 입출력은 CPU가 낭비된다는 단점이 있으므로, 보통 기다리는 시간 동안 CPU 제어권은 다른 프로세스에게 넘어가게 됩니다. 반면 비동기식 입출력은 시스템 콜로 운영체제에게 입출력 명령을 부탁한 뒤 다시 바로 CPU 제어권을 얻습니다.<br>
<br>
</details>

## 인터럽트 관련 질문
<details markdown = "1">
<summary>인터럽트란 무엇이고 왜 필요한가요?</summary>
인터럽트는 주변 장치나 입출력 장치가(정확하게는 입출력 장치의 컨트롤러) CPU 서비스를 필요로 할때 신호를 발생시켜 서비스를 요청하는 메커니즘입니다.<br>
예를 들어, 하드디스크에서 데이터를 읽는 작업을 CPU가 요청을 했다면, CPU는 작업이 완료될 때 까지 기다리는 대신, 다른 작업을 계속해서 수행할 수 있습니다.<br>
이후 하드디스크가 데이터를 읽기 작업을 완료하면 (컨트롤러에서) 인터럽트를 발생시켜 CPU에 알립니다. 이러한 방식으로 CPU의 효율성을 높일 수 있습니다.<br>
<br>
참고 - 컨트롤러란 장치내 작은 CPU로 인터럽트를 발생시켜 CPU에 보고를 하는 역할<br>
로컬 버퍼 - 컨트롤러 내에 위치하며, 장치로 부터 들어오고 나가는 데이터의 임시 저장을 위한 작은 메모리<br>
<br>
꼬리질문 1 - 인터럽트가 발생한 후 어떻게 프로세스는 다시 이어서 실행하나요?<br>
인터럽트가 발생하면, CPU는 먼저 현재 수행 중이던 작업의 상태를 저장합니다. 그리고 인터럽트 요청을 처리한 후, 인터럽트가 발생하기 직전의 상태를 복구시키면서 중단되었던 작업을 재개하게 됩니다. 이렇게 함으로써, CPU는 인터럽트에 반응하면서도 본래의 작업을 계속 수행할 수 있습니다<br>
<br>
꼬리질문 2 - 인터럽트 처리루틴이란 무엇인가요?<br>
인터럽트 처리루틴은 운영체제가 각 인터럽트의 종류마다 가지고 있는 처리 절차입니다. 예를 들어, 키보드에서 입력이 들어오면, 운영체제는 키보드 인터럽트 처리루틴을 실행시켜 키보드로부터 입력받은 내용을 메모리의 특정 부분에 저장하고 해당 프로그램에 키보드 입력이 들어왔음을 알립니다. 이런 방식으로 운영체제는 다양한 인터럽트에 대응할 수 있습니다.<br>
<br>
꼬리질문 3 - CPU는 인터럽트가 발생했을 때 이를 어떻게 인지하나요?<br>
CPU는 명령하나를 수행할때마다 인터럽트가 발생했는지 인터럽트 라인을 확인하게 됩니다.<br>
이때 인터럽트 신호가 있다면, CPU는 다음 명령을 수행하기 전 인터럽트 처리를 하게 되고, 그렇지 않으면 다음 명령을 계속 수행하게 됩니다.<br>
</details>

<details markdown = "1">
<summary>인터럽트 종류에는 어떤 것들이 있을까요?</summary>
인터럽트의 종류에는 하드웨어 인터럽트와 소프트웨어 인터럽트가 있습니다.<br>
이 둘은 CPU의 서비스가 필요한 경우, CPU 옆에 있는 인터럽트 라인에 신호를 보내어 인터럽트가 발생했다는 것을 알려주는것은 동일하나, 하드웨어 인터럽트는 컨트롤러등 하드웨어 장치가 인터럽트 라인을 세팅하는 반면, 소프트웨어 인터럽트는 소프트웨어가 인터럽트를 세팅한다는 차이점이 있습니다.<br>
소프트웨어 인터럽트는 trap이라는 용어로 주로 불리며 예외상황, 시스템 콜 등이 있습니다.<br>
하드웨어 인터럽트는 보통 IO 디바이스에서 발생하는 인터럽트 뜻합니다.(ex: 키보드 연결, 마우스 연결)<br>
소프트웨어 인터럽트 중 예외상황이란 사용자 프로그램이 0으로 나누는 연산 등 비정상적 작업을 시도하거나, 자신의 메모리 영역 밖을 접근하려는 등 권한 없는 작업을 시도할때, 이에 대한 처리를 위해 발생시키는 인터럽트 입니다.<br>
시스템콜은 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하는 방법입니다.<br>
<br>
참고- 예외상황 시스템콜 모두다 인터럽트를 발생시킨 후 CPU의 제어권이 운영체제로 넘어감<br>
</details>

<details markdown = "1">
<summary>인터럽트가 발생한 후 동작 방식에 대해 설명해주세요.</summary>
예를들어 B라는 프로그램이 실행 중에 I/O 작업이 필요해 시스템 콜을 통해 작업을 요청한 후 대기 상태(봉쇄 상태)에 있고, 현재 CPU는 A라는 프로그램을 실행 중이라고 가정해 보겠습니다.<br>
장치(ex: 디스크)의 컨트롤러가 B 프로그램에 작업을 완료 시키면, CPU에게 인터럽트를 발생시킵니다.<br>
CPU는 인터럽트를 받으면, 우선 현재 실행 중인 프로그램 A의 상태를 저장해야 합니다.<br>
이를 위해 CPU는 프로그램 A의 정보들, 예를 들어 PC(CPU가 수행해야할 메모리 주소를 담고 있는 레지스터)나 레지스터 정보등을 PCB에 저장합니다. 이는 나중에 프로그램 A의 작업을 재개하기 위함입니다.<br>
그런 다음에, CPU의 제어는 현재 실행 중인 프로그램에서 인터럽트를 처리하기 위한 처리루틴으로 전환됩니다.이때 CPU의 제어가 현재 프로그램에서 다른 프로그램(여기서는 처리루틴)으로 넘어가는 것을 컨텍스트 스위칭이라고합니다.<br>
이제 CPU는 해당 인터럽트를 처리하는 루틴을 수행하게 됩니다. 이 루틴은 일반적으로 운영체제 커널의 일부로, I/O 작업의 결과를 메모리에 적재하는 등의 작업을 수행합니다.(이때 blokced를 ready 상태로 바꾸는 것도 함)<br>
인터럽트 처리 완료후엔 앞서 저장했던 PCB에서 프로그램 A의 정보를 불러와 CPU에 복원합니다.<br>
복원 후에 CPU는 프로그램 A의 작업을 이어서 수행할 수 있게 됩니다.<br>
<br>
참고<br>
레지스터란 무엇인가 - CPU내부에 있는 빠른 저장 공간으로 계산에 사용되는 데이터나 중간 결과를 보관하고 있다. 이의 예로는 PC, 명령어 레지스터, 누산기, 일반 레지스터 등이 있다.<br>
PC란 현재 CPU가 실행중인 명령어의 주소를 가리키는 레지스터입니다.<br>
PCB는 운영체제가 각 프로세스를 관리하기 위해 사용하는 자료구조로, 실행 중인 코드의 메모리 주소와 레지스터 및 PC의 값들이 저장됩니다.<br>
</details>

## 메모리 관련 질문

<details markdown = "1">
<summary>기준 레지스터와 한계 레지스터가 무엇인지 설명하고, 이들을 어떻게 이용해 메모리 보호를 수행하는지 설명해주세요.</summary>
기준 레지스터와 한계 레지스터는 운영체제의 메모리 보호 방법에 사용되는 두 가지 레지스터입니다.<br>
기준 레지스터는 프로그램이 접근할 수 있는 메모리 상의 가장 작은 주소를 저장하고, 한계 레지스터는 프로그램이 접근할 수 있는 메모리의 범위를 저장합니다. 따라서 프로그램은 기준 레지스터의 주소부터 기준 레지스터의 값과 한계 레지스터 값을 더한 주소 사이의 영역에만 접근할 수 있습니다. 만약 이 범위를 넘어서는 메모리 영역에 접근하려고 하면, 운영체제는 예외 상황으로 처리하고, 프로그램을 강제 종료시키는 등의 처리를 합니다.<br>
이렇게 하면, 프로그램이 메모리의 허가되지 않은 영역, 예를 들어 다른 프로그램이나 운영체제가 위치하는 영역 등에 침범하는 것을 방지할 수 있습니다. 다만 이 방법은 프로그램이 메모리의 한 영역에 연속적으로 위치할 경우에만 사용할 수 있습니다.<br>
<br>
그리고 메모리 접근 명령 자체는 특권 명령이 아니지만, 기준 레지스터와 한계 레지스터의 값을 설정하는 연산은 특권 명령입니다. 그래서 운영체제만이 기준 레지스터와 한계 레지스터 값을 변경할 수 있고, 사용자 프로그램은 이 값들을 변경할 수 없습니다. 이렇게 함으로써 보안을 유지할 수 있습니다.<br>
</details>

## 기타 질문
<details markdown = "1">
<summary>커널 모드와 사용자 모드의 차이에 대해 간단히 설명해주세요.</summary>
커널 모드는 운영체제가 CPU를 제어하고 있을 때에 해당합니다. 여기에서 운영체제는 코드가 실행되며, 모든 종류의 명령, 특히 하드웨어를 직접 제어하는 등의 특권 명령을 수행할 수 있습니다.<br>
반면 사용자 모드는 사용자 프로그램이 CPU의 제어권을 가지고 제한적인 명령만 실행할 수 있는 모드입니다.<br>
사용자 프로그램이 특권 명령을 실행 하기 위해서는 운영체제에게 이 명령을 대신해줄 것을 요청하는데, 이를 시스템 콜이라고 합니다.<br>
즉 프로그램이 자신의 주소 공간 내에 있는 함수가 아닌 커널의 함수를 호출하는 것을 뜻합니다.<br>
<br>
특권 명령 - 사용자 프로그램이 사용했을 때 큰 문제가 발생할 수 있는 명령으로, 보안 과 관련되어있으며 mode bit가 0일때 사용 가능
</details>

<details markdown = "1">
<summary>시스템 콜이란 무엇인가요?</summary>
시스템 콜(system call)은 사용자 모드에서 실행되는 프로그램이 운영체제의 서비스를 요청하기 위한 일종의 인터페이스입니다. 사용자 모드에서 실행되는 프로그램이 보안이 필요한 작업을 수행하거나 하드웨어와 같은 시스템 자원에 접근하고자 할 때 직접적으로 이를 수행할 수 없기 때문에, 운영체제가 이런 작업을 대신해주도록 요청하는데 이것이 바로 시스템 콜입니다.<br>
예를 들어, 파일을 열거나 네트워크 통신을 하고자 하는 등의 작업이 시스템 콜을 통해 이루어지게 됩니다. 시스템 콜을 사용하면 운영체제는 프로그램에 필요한 서비스를 제공하면서도, 보안을 유지하고 시스템의 안정성을 보장할 수 있습니다.<br>
<br>
이거 또한 인터럽트처럼 인터럽트 라인에 인터럽트를 세팅함으로서 이루어짐.
</details>

<details markdown = "1">
<summary>시스템 콜을 발생시킨 후 어떤 과정이 발생하나요?</summary>
사용자 프로그램이 시스템 콜을 호출하면 (예: 디스크로 파일을 읽어오는 경우), CPU의 제어권이 운영체제로 넘어갑니다. 이때 사용자 프로그램의 상태, 즉 프로세스의 컨텍스트(Context)는 프로세스 제어 블록(Process Control Block, PCB)에 저장됩니다.<br>
다음으로 CPU는 커널 모드로 전환되고, 운영체제는 시스템 콜에 해당하는 서비스 루틴을 실행합니다. 예를 들어, 디스크에서 파일을 읽어오는 시스템 콜의 경우, 운영체제는 디스크 컨트롤러에게 해당 파일을 읽어오라는 명령을 내립니다<br>
만약 시스템 콜이 블로킹 연산이라면, 해당 시스템 콜을 호출한 프로세스는 봉쇄 상태로 전환되며, CPU 제어권은 다른 프로세스에게 넘어갑니다. 시스템 콜이 완료되면, 원래의 프로세스는 준비 상태(ready state)가 되고, 스케줄러에 의해 다시 실행 상태(running state)로 전환될 수 있습니다<br>
반면, 시스템 콜이 논-블로킹 연산이라면, 해당 시스템 콜을 호출한 프로세스는 제어권을 즉시 다시 얻게 되고, 다른 작업을 계속 수행할 수 있습니다.<br>
<br>
블로킹 - 특정 작업이 완료될때까지 프로그램의 실행이 멈춤. 이 시간 동안 프로세스는 CPU를 사용하지 않고, 다른 CPu가 사용할 수 있도록 봉쇄상태<br>
논블로킹 - 특정 작업(예: 입출력 요청)이 완료되지 않더라도 프로그램의 실행이 계속됩니다. 이 방식에서는 작업의 완료 여부와 관계 없이 즉시 제어가 프로그램으로 돌아갑니다<br>
이 경우, 프로세스는 시스템 콜의 결과를 나중에 확인하게 될 수도 있습니다.<br>
</details>

<details markdown = "1">
<summary>모드 비트가 무엇인지 설명해주세요.</summary>
모드 비트(mode bit)는 CPU의 상태를 나타내는 비트로서, 현재 CPU가 어떤 모드에서 실행되고 있는지를 표시합니다. 일반적으로 이 비트는 1 또는 0의 값을 가질 수 있습니다.<br>
모드 비트가 0일 경우, CPU는 커널 모드(Kernel Mode)에서 실행되고 있는 것으로, 모든 종류의 명령어를 실행할 수 있는 상태를 나타냅니다. 이 모드에서는 입출력 관리, 메모리 관리, 파일 시스템 관리 등의 중요한 시스템 연산을 수행할 수 있습니다.<br>
반면, 모드 비트가 1일 경우, CPU는 사용자 모드(User Mode)에서 실행되고 있는 것으로, 제한된 명령어만 실행할 수 있는 상태를 나타냅니다. 이 모드에서는 일반적인 프로그램 실행을 수행하며, 보안이 필요한 작업이 필요할 경우 시스템 콜을 통해 이를 커널 모드로 전환하여 수행하게 됩니다.<br>
따라서 모드 비트는 운영체제가 사용자 프로그램과 시스템의 민감한 자원 간의 보안을 유지하면서도 필요한 작업을 수행할 수 있도록 하는 중요한 역할을 합니다.<br>
<br>
사용 이유 - 사용자 프로그램이 CPU 제어권을 가지고 있을 때 운영체제가 이를 제어하지 못하므로<br>
</details>

<details markdown = "1">
<summary>시분할 시스템(Time Sharing)이란 무엇이죠??</summary>
시분할 시스템이란 다중 사용자 지원을 위해 컴퓨터 응답 시간을 최소화하는 시스템입니다. 이때 응답 시간을 최소화 하기 위해 각 응용 프로그램이 CPU를 점유하는 시간을 잘게 쪼개어 실행 될 수 있게 해줍니다.<br>
이를 통해 각 사용자는 독립적인 컴퓨팅 환경을 가진것 처럼 느낄 수 있습니다.<br>
<br>
유사 질문 1 - 멀티 태스킹이란 무엇인가??<br>
단일 CPU 환경에서 여러 응용프로그램이 동시에 실행되는 것처럼 보이게 하는 시스템입니다.<br>
이때 응답시간 ~~~ (위랑 똑같이 대답)<br>
<br>
참고 -  멀티태스킹은 시분할 시스템과 목표는 다르지만, 결과적으로 구현방식은 거의 동일한 시스템이라고 이해<br>
<br>
유사질문 2 - 멀티 프로그래밍이란 무엇인가??<br>
멀티 프로그래밍이란 메모리에 여러 프로그램을 동시에 올리는 기능입니다. 이를 통해 CPU가 한 프로그램에서 다른 프로그램으로 빠르게 전환함으로써,CPU의 이용률을 극대화할 수 있습니다.<br>
<br>
만약 예시를 들어보라 할 경우<br>
예를들어 만약 프로그램이 입출력 작업을 수행한다면, 이는 CPU처리 속도에 비해 느리기 때문에 CPU는 유휴 상태에 빠지게 됩니다.<br>
이런 상황에서 메모리에 다른 프로그램이 올려져 있다면, 입출력 작업 동안 CPU는 대기 하는 것이 아닌, 다른 프로그램을 실행함으로서 CPU를 효율적으로 사용할 수 있습니다.<br>
<br>
유사질문 3 - 멀티 프로세싱은 무엇인가?<br>
멀티 프로세싱은 여러 CPU에 하나의 프로세스를 여러 단위로 쪼개 병렬로 실행하게끔 해서 실행 속도를 극대화 시키는 시스템입니다.<br>
</details>


