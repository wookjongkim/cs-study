# 자바

<details markdown = "1">
<summary>기본형과 참조형이 무엇인지와 그에 대한 차이를 설명해주세요.</summary>

자바에서는 총 8가지의 기본형 타입(byte, short, int, long, float, double, char, boolean)을 미리 정의하고 제공해줍니다.<br>
기본형 변수는 메모리의 스택 영역에 할당되며, 값이 저장될때 해당 메모리 위치에 직접 저장됩니다.<br>
참조형 타입에는 클래스, 인터페이스, 배열 등이 있습니다. 참조형 변수는 메모리의 스택 영역에 할당되며, 객체는 힙 영역에 할당됩니다.<br>
이때 참조형 변수는 힙 영역에 저장된 객체의 주소를 가리키고 있는 것이 특징입니다.
</details>

<details markdown = "1">
<summary> 자바에서 '=='연산자와 'equals()' 메서드의 차이에 대해 설명해주세요 </summary>

두 변수가 같은 객체(같은 메모리 공간)를 가리키는지 확인하려면 ==를 사용하고, 객체의 내용 자체가 동일한지 확인하려면 equals()를 사용해야 합니다. <br>
기본형 변수의 경우 ==를 사용하면 됩니다. 하지만 참조형 변수의 경우, 특히 문자열이나 사용자 정의 클래스와 같은 객체를 비교할 때는 equals() 메서드를 사용하는 것이 좋습니다.<br>
참고: equals는 override 할 수 있기 때문에 사용자가 원하는 논리적인 통일성을 비교할 수 있다.<br>
참고 : equals는 주소 값을 자체를 비교하는 것은 아니지만 주소값을 통해서 비교를 함
</details>

<details markdown = "1">
<summary> call by reference 와 call by value의 차이에 대해 설명해주세요.</summary>

call by value와 call by reference는 함수 호출 시 인자 전달 방식의 차이를 나타냅니다.<br>
call by value는 함수에 인자를 전달할때 값을 넘겨받은 메소드에서
값을 복사하여 새로운 지역 변수에 저장하는 방식입니다. 이 경우, 함수 내에서 인자 값이 변경되더라도 원래 변수에는 영향을 미치지 않습니다.<br>
반면 call by reference는 함수에 인자를 전달할때 변수의 주소를 전달하는 방식입니다. 이 경우 함수 내에서 인자 값이 변경되면 원래 변수의 값도 함께 변경됩니다.<br>
자바에서는 기본형 변수를 함수의 인자로 전달할때 call by value 방식을 사용하고, 참조형 변수를 전달할때는 call by reference의 개념과 유사한 방식을 사용합니다. 하지만 정확히는 call by value로 참조 주소가 전달되기때문에, 종종 call by sharing이라고도 불립니다.
<br>참고 : https://velog.io/@ahnick/Java-Call-by-Value-Call-by-Reference
</details>

<details markdown = "1">
<summary> 클래스 변수, 지역 변수, 인스턴스 변수의 차이에 대해 설명해주세요 </summary>
클래스 변수는 static 키워드를 사용해 선언되며, 클래스 레벨에서 정의가 됩니다. 이는 해당 클래스의 모든 객체가 공유하며, JVM의해 클래스가 로드될때 메모리에 할당됩니다.<br>
인스턴스 변수는 객체마다 개별적으로 존재하며, 객체가 생성될 때 메모리에 할당됩니다.<br>
지역변수는 메서드나 블록 내에서 선언되며, 해당 영역 내에서만 사용할 수 있습니다. 이는 스택 영역에 할당되며, 영역을 벗어나면 메모리에서 해제됩니다.
<br><br>
참고 : 클래스 변수, 인스턴스 변수 둘다 멤버 변수<br>
참고 : 인스턴스 변수는 객체가 생성될 때마다 힙(heap) 영역에 매번 새로 생성되며, 각 객체마다 독립적인 변수를 가지게 됩니다. 지역 변수는 메서드가 호출될 때마다 스택(stack) 영역에 새로 생성되고 메서드 호출이 종료되면 소멸합니다. 반면에 클래스 변수는 static Area에 한 번만 생성되어 해당 클래스의 모든 객체가 공유합니다.
멤버변수는 지역 변수와 다르게 각 타입의 기본 값으로 자동 초기화<br> 
참고 : 자바를 실행했다고 바로 메모리에 올라가는 것이 아님, 클래스 로드 시점은 다음과같다<br>
1. 클래스 인스턴스를 생성하려할때
2. 클래스의 정적 멤버에 접근하려할떄!(중요!!)
3. 클래스를 직접 로드하는 경우 Class.forName()
</details>

<details markdown = "1">
<summary>상속이란 무엇인가요?</summary>
상위 클래스를 상속 받게 되면 하위 클래스, 즉 상속받은 클래스는 상위 클래스의 변수나 메서드를 사용할 수 있게 됩니다.<br>
이게 가능한 이유는 하위 클래스 생성 시 상위 클래스의 생성자가 먼저 호출되고 하위 클래스의 생성자가 호출되로고 프로그램 내부에 이미 설정되어 있기 때문입니다. <br>
즉 하위 클래스 생성자에서 super()를 자동으로 호출하게 됩니다.<br>
이러한 상속에는 예약어 extends가 사용됩니다.
</details>

<details markdown = "1">
<summary>오버로딩과 오버라이딩에 대해 설명해주세요</summary>
오버로딩은 같은 이름의 메서드를 여러 개 정의하되, 매개변수의 개수나 타입이 다르게 하는 것입니다.
이를 통해 다양한 매개변수를 받을 수 있는 메서드를 구현할 수 있습니다.
반면에 오버라이딩은 상속 관계에서 자식 클래스가 부모 클래스가 정의한 메서드를 재정의하는 것입니다. 
메서드의 시그니처는 동일하게 유지되지만, 구현 내용이 변경되어 자식 클래스의 요구에 맞게 동작할 수 있습니다. 
이를 통해 다형성을 구현할 수 있습니다.

참고 : 다형성이란 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있도록 하는 것!
</details>

<details markdown = "1">
<summary>접근 제어자에 대해 설명해주세요</summary>
접근 제어자란 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 합니다.<br>
이러한 접근제어자에는 private, default, protected, public이 있습니다.<br>
private의 경우에는 같은 클래스내에서만 접근이 가능하고, default의 경우에는 같은 패키지 내에서만 접근이 가능합니다.<br>
protected의 경우에는 같은 패키지내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하고 public의 경우에는 접근 제한이 전혀 없습니다.<br>
</details>

<details markdown = "1">
<summary>클래스란 무엇인가요?</summary>
클래스는 객체의 속성과 기능을 코드로 구현한것입니다. 자바에서의 모든 코드는 클래스 안에서 정의되어있습니다.
</details>

<details markdown = "1">
<summary>static 예약어에 대해 설명해주세요</summary>
자바에서 static은 클래스 레벨에서 공유되는 멤버를 선언하는데 사용되는 예약어입니다.<br>
이 키워드를 사용해 변수, 메서드, 내부 클래스를 정의할 수 있습니다.<br>
static 변수는 클래스의 모든 인스턴스가 공유하는 변수로 클래스 로드 시 메모리에 한번 할당되고, 인스턴스 생성과 무관하게 사용 가능합니다.<br>
static 메서드는 클레스 레벨에서 동작하는 메서드로, 인스턴스 생성없이 호출 할 수 있습니다.<br>
static 내부 클래스는 클래스 내부에 정의된 정적 클래스로, 외부 클래스와 독립적으로 동작합니다.<br>
따라서 외부 클래스의 인스턴스 생성과 상관없이 사용할 수 있습니다.<br>
참고 : 보통 유틸리티 메서드를 포함하는 클래스에 사용<br>
</details>

<details markdown = "1">
<summary>final 예약어에 대해 설명해주세요</summary>
final 예약어는 값이 변하지 않는 상수를 선언할때나 메서드의 재정의 및 클래스 확장을 방지하기 위해 주로 사용됩니다.<br>
변수에 final을 붙이면 해당 변수는 변경 될수 없는 상수가 되고, 메서드에 final을 붙으면 이는 재정의가 불가능해집니다.<br>
또한 클래스에 final을 붙으면 다른 클래스에서 이를 상속할 수 없습니다.
</details>

<details markdown = "1">
<summary>추상 클래스에 대해 설명해주세요</summary>
일반적으로 추상 메서드를 가지고 있는 클래스를 추상 클래스라고 합니다. 추상 메서드는 구현부가 없는 메서드를 뜻합니다.<br>
이러한 추상 클래스를 상속받은 클래스는 추상 메서드를 모두 구현하던가, 본인도 추상 클래스로 만들어야 오류가 발생하지 않으며 예약어 abstract를 사용합니다.<br>
참고 : extends 사용<br>
참고 : abstract 안 붙여도 구현부가 없는 메서드는 추상 메서드로 분류함<br>
참고 : 추상 클래스는 일반 메서드도 가질 수 있음<br>
참고 : 새로운 클래스를 작성할때 일종의 설계도 역할을 해줌, 공통 기능을 상속해 주기 위한 용도<br>
</details>

<details markdown = "1">
<summary>인터페이스에 대해 설명해주세요</summary>
인터페이스는 자바에서 클래스들이 공통적으로 가져야 할 메서드를 명세하는 추상화된 개념입니다.<br>
이러한 인터페이스는 추상 메서드와 상수만을 가질 수 있으며, 인스턴스화 할 수 없습니다.<br>
사용 목적에 대해 간단히 말씀드리자면 우선 클래스들이 가져야 할 메서드의 시그니처를 정의함으로서, 클래스가 구현해야 하는 행동을 지정할 수 있습니다.<br>
또한 인터페이스를 구현하는 여러 클래스는 동일한 인터페이스 메서드를 사용하여 다양한 구현을 제공할 수 있습니다.<br>
이를 통해 구현체에 의존하지 않고 인터페이스에 의존하게 되어 유연성과 확장성이 향상됩니다.<br>

참고 : 추상 클래스는 추상 메서드를 가진 클래스이고, 인터페이스는 추상 메서드로만 이루어진 클래스<br>
참고 : 인터페이스, 추상클래스 둘의 메서드는 상속되어야 하기 때문에 final 키워드 붙지 않음
</details>

<details markdown = "1">
<summary>추상 클래스와 인터페이스의 차이에 대해 설명해주세요</summary>
추상 클래스는 상속받은 클래스의 기능을 이용하고 확장하는 것이고, 인터페이스는 하위클래스에게 일종의 설계도를 제공하는 것입니다.<br>
추상 클래스 상속과 같이 extends 관계를 가진 경우에는 자식이 부모의 필드나 메서드를 참조할 수 있기 때문에, 자식이 부모의 기능을 확장한 구조로 이루어집니다.<br>
따라서 부모-자식 관계 뿐 아니라, 같은 부모에서 확장된 자식 클래스들끼리도 어느정도 역할에 공통점이 존재해야 합니다.<br>
반면 인터페이스의 구현체의 경우, 자식들간에 전혀 아무런 관계가 없더라도 인터페이스와 관계를 맺을 수 있습니다.<br>
요약하자면 밀접하게 관련된 클래스들끼리 코드를 공유해야 할때는 추상클래스, 서로 관계 없는 클래스들끼리 관계를 맺어주고 특정 데이터 타입의 메서드를 사용하려고 할때, 해당 동작을 누가 구현해는지 중요하지 않거나<br>
다중 상속이 필요한 경우 인터페이스를 사용하는 것이 좋습니다.<br>
</details>

<details markdown = "1">
<summary>오류와 예외의 차이에 대해 설명해주세요</summary>
오류(Error)는 시스템 레벨에서 발생하고 예외(Exception)은 개발자가 구현한 로직에서 발생합니다.
</details>

<details markdown = "1">
<summary>Checked예외와 UnChecked 예외의 차이에 대해 설명해주세요</summary>
둘의 가장 명확한 구분 기준은 꼭 처리를 해야 하느냐 입니다.<br>
Checked Exception이 발생할 가능성이 있는 메서드라면 반드시 오류 처리(try/catch, throw)를 해주어야 합니다.<br>
반면 Unchecked Exception은 명시적인 예외처리를 하지 않아도 됩니다.<br>
또한 예외를 확인하는 시점에서도 구분할 수 있습니다.<br>
일반적으로 컴파일 단계에서 명확하게 Exception 체크가 가능한 것을 Checked Exception이라 하며, 실행 과정 중 발견되는 Exception을 Unchecked Exception이라고 합니다.<br>
그리고 트랜잭션 roll-back 여부에도 차이가 있습니다.
기본적으로 Checked Exception은 예외가 발생하면 트랜잭션을 roll-back하지 않고 예외를 던져주는 반면, Unchecked Exception은 예외 발생 시 트랜잭션을 roll-back한다는 점에서 차이가 있습니다.</br>
- 참고 : 롤백이란 트랜잭션 내에서 발생한 모든 변경 작업을 취소하고 이전 상태로 돌리는 과정(데이터 일관성 유지)
- 대표적인 Checked : Exception , UnChecked : RuntimeException
</details>

<details markdown = "1">
<summary>문자열을 리터럴(string = "abcd")로 할당하는 것과 객체(string = new String("abcd"))로 할당하는 방식의 차이가 무엇인가요?</summary>
문자열을 리터럴과 객체로 할당하는 방식의 차이는 메모리 할당 방식과 성능에 있습니다.<br>
자바 소스 코드에 포함된 모든 문자열 리터럴은 컴파일시에 클래스 파일에 저장됩니다. <br>
이후 클래스 파일이 클래스 로더에 의해 메모리에 올라갈때, 클래스 파일의 리터럴들이 JVM 내에 있는 String constant pool에 올라가게 됩니다.<br>
이때 같은 문자열 리터럴이 여러번 사용될 경우, 중복을 방지하기 위해 하나의 인스턴스를 공유하게 됩니다. <br>
이러한 리터럴 방식은 중복을 최소화 하고 메모리를 효율적으로 사용할 수 있습니다.<br>
반면 new 키워드로 문자열 객체를 생성할 시 힙 영역에 새로운 객체가 생성됩니다.<br>
이 경우에는 같은 문자열이라도 매번 새로운 객체를 생성하게 되어 메모리 사용에 비효율적 입니다<br>

참고 - String Pool이 메소드 영역에 위치한다는 표현은 JVM 구조를 간략화한 표현입니다. 사실, 정확하게는 String Pool은 Heap 영역에 위치한 특별한 영역입니다.<br>
</details>

<details markdown = "1">
<summary>자바에서는 왜 String을 불변 객체로 만들었을까요?</summary>
만약 문자열이 불변성을 가지지 않는다면, 문자열이 수정될 때마다 새로운 문자열 객체가 생성되어야 하므로 메모리 부담이 커집니다.<br>
그러나 불변성을 가진 문자열은 한 번 생성되면 그 상태가 변하지 않습니다. <br>
따라서 동일한 문자열을 여러 번 사용해도 String Pool에서는 단 한 번만 저장되므로, 메모리 사용에 있어서 효율적이며, 중복 생성을 방지해 메모리 공간 절약 및 성능을 향상시킬수있습니다.<br>
또한 다른 코드에 의해 예기치 않게 변경되는 것을 막을 수 있고, 여러 쓰레드에서 동시에 접근하더라도 별도의 동기화 없이 스레드 안전성을 보장할 수 있습니다.<br>

참고 
MutableString str = new MutableString("Hello, World!");<br>
str.append("!")<br>
이 경우 동일한 문자열을 가리키는 다른 변수가 있을 때 원치 않는 변경이 일어날 수 있기에 변경할때마다 새로운 문자열 객체를 생성해야함<br>
String이 불변인 이유 -> 내부에 char[] value 배열이 final임! <br>
</details>

<details markdown = "1">
<summary>StringBuffer, StringBuilder 차이는 무엇이죠?</summary>
StringBuilder와 StringBuffer는 모두 문자열을 변경하거나 추가하는 연산을 제공하는 가변성 클래스입니다<br>
이 둘을 가르는 차이점은 동기화에 있습니다<br>
StringBuffer는 각 메서드에 대한 동기화를 지원하므로 멀티쓰레드 환경에서 안전합니다.<br>
즉 여러 스레드가 동시에 객체를 변경할 수 없으므로, 멀티스레드 환경에서 사용하면 좋습니다<br>
반면 StringBuilder는 동기화를 지원하지 않습니다. 하지만 단일 스레드 환경일 시 더 빠른 성능을 보입니다.<br><br>

참고 - 문자열 끼리 더하기 할시, 실제로는 새로운 객체를 생성한다기 보단(반은 맞고 반은 틀림), 컴파일 전 내부적으로 STringBuilder 클래스를 만들어서 사용<br>
즉, "hello" + "world" 문자열 연산이 있다면 이는 new StringBuilder("hello").append("world").toString() 과 같다는 말이다.<br>
참고 - 소켓과 같은 비동기 상황에서는 Buffer 사용하기<br>
참고 - StringBuilder와 StringBuffer는 문자열을 추가하거나 변경할 때, 새로운 객체를 생성하는 것이 아니라 기존 객체를 직접 변경합니다.<br>
참고 - String은 불변이기에 멀티쓰레드 상황 생각할 필요 X<br>

꼬리질문 - 왜 동기화가 걸려있으면 느린걸까요?
동기화란 여러 스레드가 동시에 특정 코드블록이나 메서드에 접근하는 것을 방지하여, 데이터 불일치 문제를 해결하는 기법입니다.<br>
예를들어 두개의 스레드가 동시에 StringBuffer 객체를 수정하려고 시도하면, 동기화된 메서드는 한번의 하나의 스레드의 작업만을 허용합니다.<br>
이로 인해 다른 스레드는 첫번째 스레드가 작업을 완료할때까지 기다려야하며, 이 동안 성능이 저하될수 있습니다.<br>
이렇게 스레드가 다른 스레드의 작업을 완료하기를 기다리는 것을 블로킹이라고 합니다. 이러한 블로킹은 많은 시스템 리소스를 소비하고,<br>
이 동안 CPU는 유휴상태가 될 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>왜 StringBuilder가 단일 스레드 환경에서 더 빠른 성능을 보이죠? </summary>
StringBuilder가 단일 스레드 환경에서 더 빠른 성능을 보이는 이유는 '동기화 오버헤드' 때문입니다.<br>

동기화는 멀티스레드 환경에서 데이터의 일관성을 유지하기 위해 필요한 작업이지만, 그 과정에서 추가적인 시스템 리소스를 소모합니다. 이를 '동기화 오버헤드'라고 합니다.<br>

StringBuffer의 모든 주요 메소드는 동기화 되어 있습니다. 따라서 멀티스레드 환경에서는 안전하지만, 단일 스레드 환경에서는 필요 없는 동기화 비용이 발생하게 됩니다.<br>

반면에 StringBuilder는 동기화를 지원하지 않습니다. <br>
그래서 동기화에 따른 오버헤드 없이 작동하기 때문에, 단일 스레드 환경에서는 StringBuilder가 StringBuffer보다 빠른 성능을 보이게 됩니다."
</details>

<details markdown="1">
<summary>String, StringBuffer, StringBuilder 차이:star:  </summary>
A)<br>

<img src="https://user-images.githubusercontent.com/78812317/171040842-1b72da3f-0b74-4c14-b7f3-3ea84399c5c8.png">
<br>
String 객체는 한번 생성되면 할당 메모리 공간이 변하지 않습니다. 따라서 값이 변경되지 않습니다.<br>
장점-불변이기때문에 단순 조회연산에서 타 클래스보다 빠르고, 불변이기때문에 동기화를 신경쓸 필요가 없습니다.<br>
단점-문자열연산이 자주 일어나면 더이상 참조되지 않는 객체는 GC대상이 되며 이들이 쌓입니다.<br>
<br>
StringBuffer, StringBuilder는 mutable(가변)입니다. 문자열 연산 시 메모리 크기를 변경시켜 문자열이 변경됩니다.<br>
문자열 연산이 자주 있을 시 사용하는 것이 좋습니다.<br>
둘 사이의 차이는 동기화 여부에 있습니다. <br>
StringBuffer는 메서드마다 synchronized 예약어가 걸려있어 멀티스레드 환경에서 동기화를 지원합니다.<br>
StringBuilder는 동기화를 보장하지 않습니다. 그 대신 연산처리가 StringBuffer보다 빠릅니다.<br>
결론적으로 멀티스레드 환경에선 StringBuffer, 싱글스레드 환경에선 StringBuilder를 사용하는 것이 좋습니다.<br>
</details>

<details markdown = "1">
<summary>래퍼 클래스란 무엇이죠? </summary>
래퍼 클래스란 자바의 기본형 데이터 타입을 객체로 다루기 위한 클래스를 의미합니다.<br>
이러한 각각 기본 데이터 타입에 대응하는 래퍼 클래스가 있으며, 이를 통해 기본 데이터 타입도 객체처럼 다룰수 있습니다.<br>

참고 - int : Integer, char : Character, 나머지는 기본 타입의 앞글자만 대문자
</details>

<details markdown = "1">
<summary>래퍼 클래스를 사용하는 이유엔 어떤것들이 있을까요?</summary>
예를들어, 메서드의 매개변수로 객체가 필요한 경우 사용할 수 있을 것같습니다. 그리고 null값을 사용해야 할때 Wrapper클래스를 사용하면 null값을 표현할 수 있습니다.<br>
또한 자바의 제네릭은 기본 데이터 타입을 지원하지 않습니다. 따라서 기본 데이터 타입을 사용하려면 해당 Wrapper클래스를 사용해야 합니다.<br>
그리고 멀티스레드 환경에서 동기화 기능을 적용하기 위해 기본 타입의 값에 대한 Wrapper 클래스를 사용하게 됩니다.<br>

참고: 기본 데이터 타입은 객체가 아니라서 직접 동기화를 수행할 수 없다.(객체만 java의 동기화 메커니즘을 사용할수 있기에..)
참고 : 일반적으로 객체의 경우 외부에서 함부로 값을 변경할 수 없음...(바꿀려면 아마 set? : 캡술화 반영)
</details>

<details markdown = "1">
<summary>Boxing과 UnBoxing이 무엇이죠?</summary>
박싱은 기본 타입의 데이터를 래퍼 클래스의 인스턴스로 변환하는 것이고<br>
언박싱은 래퍼클래스의 인스턴스에 저장된 값을 기본 타입의 데이터로 변환하는 것입니다.<br>
</details>

<details markdown = "1">
<summary>AutoBoxing과 UnBoxing이 무엇인지와 사용시 주의해야할점에 대해 설명해주세요.</summary>
오토 박싱이란 기본 데이터 타입의 값을 래퍼 클래스의 객체로 변환하는 과정입니다.<br>
오토 언박싱은 래퍼 클래스의 객체가 그에 해당하는 기본데이터 타입의 값으로 변환되는 과정을 말합니다.<br>
주의해야할 점으로 우선 성능상의 이슈가 있습니다.<br>
AutoBoxing과 UnBoxing은 내부적으로 객체를 생성하거나, 참조를 변환해야 하는 과정을 거치므로 반복적인 연산이 필요한 경우 성능 저하를 일으킬 수 있습니다.<br>
또한 AutoBoxing을 통해 래퍼 클래스의 객체를 생성할때 null을 할당할 경우, 이후 UnBoxing 시 NPE가 발생할 수 있습니다.<br>
또한 == 로 값을 비교할때 값이 아닌 참조를 비교하게 되므로 이에 대해 주의해야 합니다.<br>
</details>

<details markdown = "1">
<summary>Enum이란 무엇이죠?</summary>
Enum이란 일정한 범위의 상수 집합을 정의하는데 사용하는 특별한 데이터 타입입니다.<br>
Enum은 명시적으로 특정 값들만을 가질 수 있기에, 그 외의 값들을 가지려 하면 컴파일 오류가 발생합니다. 이로 인해 코드의 안정성을 높일 수 있습니다.<br>
또한 enum의 각 상수는 해당 타입의 유일한 인스턴스를 나타내므로, 이를 통해 Singleton 패턴을 구현하는데 사용할수있습니다.<br>
따라서 멀티쓰레드 상황에서 안전<br>
<br>
참고 - ex)enum Day{Mon,Tue,Wed,Thurs,FRI,SAT,SUN) ~~~ , Day day = "not a day" // 컴파일 에러
</details>

<details markdown = "1">
<summary>프레임워크와 라이브러리의 차이에 대해 설명해주세요.</summary>
프레임워크란 소프트웨어 개발을 위해 만들어진 구조나 도구의 집합을 의미합니다.<br>
개발자는 프레임워크의 규칙과 패턴에 따라 개발을 진행하며, 프레임워크가 제공하는 틀안에서 구현한 코드를 실행하고 확장할수 있습니다.<br>
라이브러리는 소프트웨어 개발에 자주 쓰일만한 코드를 미리 구현해놓고, 필요한 곳에서 호출하여 사용 가능하도록 만들어진 집합을 뜻합니다<br>
둘다 개발 생산성을 올리기 위한 도구라는 점에서 같지만, 이 둘은 흐름에 대한 제어의 권한이 어디있냐에 따라 차이가 있습니다.<br>
즉 프레임워크는 전체적인 흐름을 자체적으로 가지고 있으며 프로그래머가 그 안에 필요한 코드를 작성하는 반면(IOC)<br>
라이브러리는 사용자가 흐름에 대해 제어를 하며 필요한 상황에 가져다 쓰는 것입니다.<br>

참고 - 프레임워크에는 라이브러리들이 포함되어있음(라이브러리가 프레임워크 구성), 라이브러리 하나가 모듈과 유사한 개념<br>
참고 - 스프링에서 JPA는 라이브러리, 개발자는 필요한 경우 JPA를 선택하고, 기능을 사용하기 위해 해당 API 호출<br>
참고 - 스프링 프레임워크 자체는 JPA 라이브러리 사용하는 것 이상을 제공, 전체적인 구조와 흐름을 제어하기 위해 IOC 컨테이너와 DI 기능 제공<br>
</details>

<details markdown = "1">
<summary>Java Collection Framework란 무엇인가요?</summary>
컬렉션 프레임워크란 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스들의 집합을 의미합니다.<br>
이는 인터페이스와 다형성을 이용한 객체지향적 설계를 통해 표준화 되어 있어 사용법을 익히기 편리하며, <br>
배열과 다르게 동적으로 크기를 조정할 수 있습니다.(또한 다양한 메서드 지원)<br>
이러한 컬렉션 프레임워크는 Collection 인터페이스와 Map인터페이스로 나뉘며, Collection 인터페이스 하위에는 List,Queue,Set 인터페이스가 있습니다.<br>
참고 - 객체만 담을 수 있고, 이는 객체의 주소를 담는 것이기에 null도 저장 가능<br>
</details>

<details markdown = "1">
<summary>자료구조와 알고리즘에 대해 설명해주세요</summary>
자료구조는 데이터를 원하는 규칙 또는 목적에 맞게 저장하기 위한 구조이고<br>
알고리즘이란 자료구조에 쌓인 데이터를 활용해 어떠한 문제를 해결하기 위한 여러 동작들의 모임을 의미합니다.<br>
</details>

<details markdown = "1">
<summary>배열과 ArrayList의 차이에 대해 말씀해주세요</summary>
배열이란 동일한 데이터 타입의 값들을 연속된 메모리 공간에 저장하는 자료구조이며, 크기를 동적으로 변경할 수 없습니다.<br>
이러한 배열의 요소는 메모리에 연속적으로 저장되며, 각 요소는 고유한 인덱스를 가지므로 Random Access가 가능합니다.<br>
즉 논리적 저장순서와 물리적 저장순서가 일치하기에 인덱스를 통해 빠르게 요소에 접근할 수 있습니다.<br>
따라서 배열은 데이터 개수가 정해져있고, 접근이 빈번할 경우 사용하기 좋은 자료구조이나 중간에 요소가 삽입되거나 삭제되는 경우엔 적합하지 않은 자료구조입니다.<br>
또한 배열은 spacial locality(공간지역성)이 보장되어 요소 접근 시 Cache hit 가능성이 커 캐시의 효율성을 높일 수 있습니다.<br>
<br>
ArrayList는 배열과 마찬가지로 데이터 타입의 값들을 연속된 메모리 공간에 저장하며, 크기를 동적으로 변경할 수 있는 자료구조입니다.<br>
ArrayList는 내부의 Object[] 배열을 가지고 있어 각 요소가 인덱스를 가지고 있고, 이를 바탕으로 Random Access가 가능합니다.<br>
따라서 ArrayList는 데이터 개수가 정해져있지 않고, 접근이 빈번할 경우 사용하기 좋은 자료구조입니다.<br>
ArrayList 또한 마찬가지로 공간지역성이 보장되어 요소 접근 시 Cache hit 가능성이 커 캐시의 효율성을 높일 수 있습니다.<br>

<br>
참고 - Random Access란 데이터의 특정 위치에 직접 접근할 수 있는 능력을 의미합니다.<br>
배열에서 각 요소가 고유한 인덱스를 가지므로, 이를 통해 요소에 직접 접근이 가능<br>
메모리 상 시작 주소 + 인덱스 x 데이터 타입 크기(참조형 변수 크기는 4byte)를 통해 해당 인덱스의 값 빠르게 접근 가능<br>
참고 - 접근이나 수정(O(1)), 삽입 삭제는 다른 요소 옮겨야 하기에 O(n); value를 바탕으로 접근한다면 순차적으로 접근하는 것 생각<br>
참고 - 공간지역성이란, 관련된 데이터들이 연속적인 메모리 주소에 위치하면 그 데이터를 빠르게 읽고 쓸수 있다.<br>
참고 - 캐시히트란 필요한 데이터가 캐시에 있다면 캐시에서 빠르게 데이터를 가져오는 것을 의미한다<br>
참고 - 캐시 히트 가능성이 높다는 캐시에서 이 데이터를 찾을 확률이 높다<br>
ArrayList에서 삽입 연산시 내부 배열의 크기의 여유가 있고, 맨끝에 추가하기만 하는 경우엔 O(1)의 시간복잡도 가짐<br>
내부가 꽉찬 경우엔 끝에 추가하더라도, 배열의 크기를 늘리고 기존 배열의 element 값들을 복사해야 하기에 O(N), 중간의 경우는 당연히 O(N)<br>
삭제의 경우에도 삭제 뒤에 애들을 앞으로 땡겨야 하기에 O(n),근데 만약 마지막 값을 지운다면 O(1)일듯
<br><br><br>
꼬리질문 - 캐시 효율성에 대해 좀더 설명해주시겠어요?<br>
컴퓨터의 CPU는 계산을 수행하기 위해 데이터가 필요한데 이 데이터들은 보통 메모리에 저장되어 있습니다.<br>
이러한 CPU는 필요한 데이터를 RAM에서 읽어 수 있지만, 여기서 직접 데이터를 읽는 것은 상대적으로 느립니다.<br>
이를 위해 훨씬 빠른 속도를 가진 메모리인 캐시를 사용하며, 필요한 데이터가 캐시에 있다면 캐시에서 빠르게 데이터를 가져올수 있는데 이를 캐시히트가 발생되었다고 합니다.<br>
하지만 캐시의 크기는 매우 작기 때문에, 모든 데이터를 저장할 수는 없습니다. 따라서 CPU는 어떤 데이터를 캐시에 저장할지 결정해야 하는데 여기서 중요한 원칙이  <br>
공간지역성입니다.<br>
이는 메모리에 인접한 위치에 있는 데이터는 함께 사용될 가능성이 높다는 원리인데, 배열의 경우 모든 요소가 메모리 상 연속적으로 위치해있습니다.<br>
따라서 한번에 여러 요소를 캐시에 저장할 수 있고, 이후 배열에 접근할때 빠른 속도를 얻을 수 있습니다.<br>
요약하자면 배열의 요소들은 메모리상에 인접해 있기때문에, 한번에 여러 요소를 캐시에 저장할 수 있고, 그래서 CPU가 배열의 데이터에 빠르게 접근할 수 있습니다.<br>
<br>
참고 - 컴퓨터에서 데이터를 읽을때, 주소가 연속적인 메모리 위치에 있는 데이터를 읽는 것이 흩어진것 보다 효과적<br>
왜냐하면 컴퓨터는 메모리에서 블록 단위로 데이터를 읽음. 따라서 배열과 같이 데이터가 연속적인 메모리 위치에 있으면, 컴퓨터는 한번에 여러데이터 읽을 수 있따.<br>
이것이 한번에 여러 요소를 캐시에 저장할 수 있다는 의미.<br>
데이터가 메모리의 여러 위치에 있으면, 컴퓨터는 여러 블록을 읽어야 함(접근하는데 더 많은 시간이 듬)<br>
연관 데이터를 가능한 가까이 두는것이 캐시를 효율적으로 사용하고 성능을 높이는데 사용<br>
캐시 라인을 기반으로 읽어옴 예를들어 arr[0]이 캐시에 로드되면,arr[1],arr[2]등 같은 캐시라인에 있는 배열 요소도 같이 캐시에 로드됨<br>
즉 cpu가 램에서 데이xj를 가져올때 캐시 라인 단위로 가져옴(일반적으로 64바이트)<br>
따라서 cpu가 arr[0]의 값을 가져올때 캐시는 arr[0]을 포함하는 메모리 블록을 가져오며 여기엔 arr[0]제외 인접 데이터들도 포함됨<br>
따라서 arr[1],arr[2]는 캐시에 저장되고 나중에 접근할때는 RAM에 접근할 필요 X<br>

</details>
<details markdown = "1">
<summary>LinkedList에 대해 아시는 대로 설명해주세요.</summary>
LinkedList란 각 노드가 데이터와 포인터를 가지고 연결되어 있는 방식으로 데이터를 저장하는 자료구조입니다.<br>
이러한 링크드 리스트의 종류로는 단방향, 양방향, 원형 링크드리스트들이 존재합니다.<br>
LinkedList의 각 요소는 메모리상에 불연속적으로 배치되어 있습니다.<br>
따라서 특정 인덱스 요소에 접근하려면 ArrayList와 다르게 순차적으로 하므로 접근에 최적화된 자료구조는 아닙니다<br>
하지만 삽입 삭제가 빈번하게 일어나는 경우에는 유용한 자료구조이며, CPU 스케쥴링이나 메모리 관리 등에서 사용되는<br>
큐나 스택등의 자료구조를 구현하는데 사용될 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>ArrayList와 LinkedList의 차이에 대해 설명해주세요.</summary>
"ArrayList와 LinkedList는 자바에서 제공하는 주요 자료구조로서 각각이 독특한 특성을 가지고 있습니다.<br>
ArrayList는 동적 배열의 형태를 가지고 있어, 데이터가 메모리 상에서 연속적으로 배치됩니다.<br>
이로 인해 인덱스를 통해 빠르게 요소에 접근하는 것이 가능합니다. 이를 'random access'라고 합니다.<br>
그러나 이런 특성 때문에 중간에 새로운 요소를 삽입하거나 기존 요소를 삭제할 때는 배열의 요소들을 이동시키는 추가적인 작업이 필요합니다<br>
.이는 비효율적일 수 있습니다. 또한, 배열이 꽉 차면 크기를 늘려야 하며 이 과정에서도 시간이 소요됩니다. 하지만 ArrayList의 공간 지역성이 보장되므로, 캐시 히트 가능성이 높아져서 캐시의 효율성이 좋습니다.<br>

반면, LinkedList는 연결 리스트의 형태를 가지며, 각 요소가 메모리 상에서 불연속적으로 배치됩니다.<br>
이로 인해 인덱스를 통한 빠른 접근이 어렵습니다. 대신, LinkedList는 노드의 연결 정보만 변경함으로써 요소의 삽입과 삭제를 매우 효율적으로 수행할 수 있습니다.<br>
특히, 리스트의 시작 부분(head)나 끝 부분(tail)에서의 삽입 및 삭제는 매우 빠릅니다.<br> 
그러나 LinkedList는 공간 지역성이 보장되지 않아 캐시 히트 가능성이 낮으며, 이로 인해 캐시의 효율성이 상대적으로 떨어집니다.<br>

요약하자면, 요소의 접근이 주로 이루어지는 경우에는 ArrayList를, 요소의 삽입과 삭제가 빈번하게 이루어지는 경우에는 LinkedList를 사용하는 것이 더 효율적일 수 있습니다."<br>
<br>
참고 - ArrayList 값 연속정 저장 : Random Access, LinkedList는 값이 산재되어 저장되어 있음<br>
첫번째 위치에 insert/remove DoublyLinkedList의 경우 O(1), ArrayList의 경우 O(N)<br>
마지막 위치에 insert/remove DoubleLinkedList의 경우 O(1), ArrayList의 경우 O(1) or O(N)<br>
중간에 insert/remove Doubly : O(N) or searchtime + O(1), ArrayList : O(N)<br>
값으로 search는 둘다 O(N)이지만 ArrayList가 나음<br>
인덱스로 값을 get, LinkedList의 경우 O(N), ArrayList의 경우 O(1)<br>
값으로 remove 시 둘다 O(N)<br>
</details>

<details markdown = "1">
<summary>왜 ArrayList의 캐시 효율성이 더 좋은지 가능한 상세히 설명해주세요</summary>
공간 지역성(spatial Locality)는 컴퓨터 프로그램에서 사용하는 데이터가 메모리의 특정 구간에 집중되어 있는 경향을 말합니다.<br>
즉, 한번 참조된 데이터 근처의 데이터가 곧 이어서 참조될 가능성이 높다는 의미이며, 이는 CPU 캐시의 설계와 밀접한 관계가 있습니다.<br>
CPU 캐시는 주기억장치(RAM)에 비해 매우 빠른 속도를 가지지만 그만큼 용량이 작아서 전체 메모리를 저장할 순 없습니다.<br>
따라서 CPU는 프로그램이 주로 참조하는 데이터를 캐시에 저장합니다. 이때 공간지역성이 있다면 한번 참조된 데이터 주변의 데이터가<br>
곧 이어서 참조될 가능성이 높으므로 이러한 데이터를 캐시에 미리 가져와 놓으면 메모리 접근 시간을 줄일 수 있습니다.<br>
ArrayList는 메모리 상에서 연속적인 데이터를 저장하는 구조를 가지고 있습니다. 따라서 한 데이터가 CPU 캐시에 로드되면 그 근처의 데이터도 함께 로드되게 됩니다.<br>
이후 이 근처의 데이터에 접근하게 되면, 이미 캐시에 데이터가 존재하므로 캐시 히트가 발생하고, 메모리 접근 시간이 크게 줄어듭니다.<br>
반면 LinkedList는 노드들이 메모리의 여기저기에 분산되어 저장됩니다.<br>
각 노드는 자신의 다음 노드에 대한 참조만을 가지고 있으며, 이 참조는 메모리상의 아무 곳에나 위치할 수 있습니다.<br>
따라서 한 노드를 참조했다고 해서 그 근처의 노드가 곧바로 참조될 확률이 낮습니다. 이것이 LinkedList에서 공간지역성이 보장되지 않는 이유입니다.<br>
이로 인해 LinkedList를 사용할때는 캐시 히트 가능성이 상대적으로 낮아지고, 이에 따라 캐시의 효율성이 떨어집니다.<br>
</details>

<details markdown = "1">
<summary>Array와 LinkedList의 차이점에 대해 설명해주세요</summary>
이둘의 주요 차이점은 데이터가 메모리에 저장되는 방식과 각 요소에 대한 접근 방식에 있습니다<br>
배열은 'Random Access'를 지원합니다. 이는 배열의 요소들이 메모리 상에서 연속적으로 위치하기 때문에 가능한 것입니다<br>
따라서, 인덱스를 통해 배열의 특정 요소에 직접 접근할 수 있으며, 이러한 접근은 일정한 시간복잡도인 O(1)를 가집니다<br>
반면에 LinkedList는 'Sequential Access'를 지원합니다. LinkedList의 요소들은 메모리 상의 임의의 위치에 있으며, 각 요소(노드)는 다음 요소를 가리키는 링크를 가지고 있습니다<br>
이 링크를 따라가면서 요소에 접근해야 하기 때문에, 특정 요소에 접근하는 데는 시간복잡도 O(N)이 소요됩니다<br>
배열에서 요소의 삽입 또는 삭제는 복잡한 작업입니다. 배열은 고정된 크기를 가지므로, 삽입 또는 삭제를 위해서는 배열의 크기를 조정하거나, 요소들을 재배치해야 합니다. <br>
이러한 작업은 시간복잡도 O(N)이 소요됩니다.<br>
반면에 LinkedList에서는 삽입 및 삭제 작업이 상대적으로 간단합니다. 특정 위치에 삽입 또는 삭제를 위해서는 단지 몇 개의 링크를 조정하면 되므로, 이 작업은 일반적으로 시간복잡도 O(1)을 가집니다.<br>
배열은 '정적 메모리 할당'을 사용합니다. 즉, 배열이 생성될 때 그 크기가 고정되며, 메모리 상에 연속적으로 할당됩니다. 따라서, 배열의 크기는 변경할 수 없습니다.<br>
반면에 LinkedList는 '동적 메모리 할당'을 사용합니다. LinkedList의 요소(노드)는 필요에 따라 생성되고, 각 노드는 메모리 상의 임의의 위치에 할당됩니다. 이러한 특성 덕분에 LinkedList는 필요에 따라 크기를 동적으로 변경할 수 있습니다."<br>
<br>
참고 -  배열은 스택 영역에 할당되고, LinkedList는 힙 영역에 할당되는 것이 일반적입니다.
</details>

<details markdown = "1">
<summary>스택과 큐의 차이점에 대해 설명해주세요</summary>
스택은 세로로된 바구니와 같은 구조로, 자료가 쌓이는 구조를 가지고 있습니다.<br>
이것은 Last in First out 특성을 가지고 있어, 가장 나중에 넣은 데이터를 가장 먼저 꺼내게 됩니다.<br>
이러한 스택은 배열로 구현하는 경우, 데이터를 제거할때 실제 데이터를 지울 필요가 없고, top 인덱스를 지우는 것만으로도<br>
데이터의 삽입과 삭제를 효과적으로 관리할 수 있습니다.<br>
큐는 가로로된 통과 같은 구조로, 데이터가 한쪽 방향으로만 흐르는 구조를 가지고 있습니다.<br>
이는 First in First Out 특성을 가지고 있어, 가장 먼저 넣은 데이터를 가장 먼저 꺼냅니다.<br>
이러한 큐는 배열로 구현하게 되면 데이터를 제거할때마다 남은 데이터를 앞으로 당겨야 하는 비효율성이 있습니다.<br>
따라서 LinkedList와 같이 삽입 삭제가 용이한 자료구조로 구현하는것이 일반적입니다.<br>
<br>
참고 - LinkedList는 노드를 앞이나 뒤에 추가시 제거하는 시간이 상수 시간에 가능<br>
</details>

<details markdown = "1">
<summary>힙에 대해 아시는 대로 설명해주세요.</summary>
힙은 최솟값 또는 최대값을 빠르게 찾아내기 위해 완전 이진트리 형태로 만들어진 자료구조입니다.<br>
힙에는 최대힙과 최소힙 두가지 유형이있습니다.<br> 
최대힙에서는 부모의 노드값이 그 자식 노드값보다 항상 크거나 같습니다.<br>
그리고 최소힙에서는 부모의 노드 값이 그 자식 노드값 보다 항상 작거나 같습니다.
이러한 힙을 사용하면 데이터 최댓값 또는 최솟값을 상수시간에 찾아낼 수 있으며, 삽입과 삭제는 로그 시간에 할 수 있기에 효율적입니다.<br>
<br>
참고<br>
이진트리 - 모든 노드의 최대 차수를 2로 제한한것<br>
완전(complete) 이진트리 - 모든 노드의 최대 차수 2 제한 + 마지막 레벨을 제외한 모든 노드 채워져 + 모든 노드는 왼쪽부터 채워져야함<br>
포화이진트리(perfect binary tree) 이진트리 - 완전 이진 트리 조건 + 마지막 레벨을 제외한 모든 노드는 두개의 자식 노드를 가짐<br>
상수시간 - 데이터 크기와 무관하게 일정한 시간을 필요로 한다는 것<br>
예를들어 배열에서 특정 인덱스의 값을 읽는 작업은 배열의 크기와 상관없이 항상 동일한 시간이 소요됨<br>
보통 배열로 구현하는 것이 효율적<br>
</details>

<details markdown = "1">
<summary>왜 힙의 삽입,삭제 연산의 시간복잡도는 O(logN)인지 설명해주세요.</summary>
힙은 완전 이진 트리의 형태를 띄고있기에 노드의 수가 늘어남에 따라 트리의 높이는 logN에 비례합니다(각 레벨에서 노드의 수가 두배로 늘어나므로 log에 비례)<br>
힙에서 삽입 및 삭제 연산은 루트 노드에서 시작하여 leaf 노드까지의 경로를 따라 이루어집니다.<br>
이 때문에 이러한 연산들은 트리에 높이에 비례하는 시간이 걸리며 이로인해 삽입 삭제 연산은 O(logN)이됩니다.<br>
예를 들어 삽입 연산의 경우 새로운 요소는 처음에 트리의 가장 하위 레벨(leaf노드)에 추가되고,그 후 힙 속성을 유지하며 적절한 위치로 이동합니다.<br>
이러한 연산은 새 요소를 부모 노드와 비교하며 진행되므로, 트리의 높이만큼의 비교가 이루어집니다.<br>
힙에서 가장 크거나 작은 요소를 삭제하면 일반적으로 루트 노드가 삭제됩니다.<br>
이후 트리의 가장 하위 레벨에서 하나의 노드를 루트로 이동시키고, 이 노드를 자식과 비교하며 적절한 위치로 이동시킵니다.<br>
이러한 연산 또한 트리의 높이에 비례하는 시간이 걸립니다.<br>
</details>

<details markdown = "1">
<summary>우선순위큐가 무엇인지와 동작원리에 대해 설명해주세요.</summary>
우선 순위 큐란 각각의 요소들이 우선순위를 가지고 있고, 요소들의 대기열에서 우선순위가 높은 요소가 우선순위가 낮은 요소보다 먼저 제공되는 자료구조입니다.<br>
우선순위 큐는 자료를 추가하는 작업과, 삭제하는 작업 모두 지원하며 데이터를 추가할때는 우선순위에 따라 적절한 위치에 삽입되며, 데이터를 제거할때는 항상 가장 높은 우선순위의 항목이 제거됩니다.<br>
이러한 우선순위큐를 구현하기 위해서 일반적으로 힙이라는 자료구조를 구현합니다.<br>
따라서 모든 정점은 자신의 자식 요소보다 우선순위가 높다는 성질과, 완전 이진 트리의 성질로 인해 삽입,삭제 시 O(logN)의 시간복잡도를 보입니다.<br>
또한 우선순위가 가장 높은 요소는 루트에 위치하므로, 이를 조회하는데에는 상수의 시간이 걸립니다.<br>
<br>
참고 - 힙은 형제노드와 대소 비교를 안함<br>
</details>

<details markdown = "1">
<summary>우선순위큐를 힙이 아닌 다른 자료구조로 구현한다면 어덯게 될까요?</summary>
힙이 아닌 배열 이나 연결리스트를 통해서도 구현할 수 있습니다.<br>
배열로 구현시, 배열의 새로운 요소를 추가하는 것은 O(1)의 시간복잡도를 가지며, 새 요소는 배열의 마지막에 추가됩니다.<br>
삭제시에는 가장 우선순위가 높은 요소를 찾아 삭제하는데 O(N)의 시간복잡도를 가집니다.(모든 요소 탐색)
조회 또한 가장 우선 순위가 높은 요소를 찾는데 O(N)의 시간복잡도를 가집니다.<br>
연결리스트로 구현시 삽입에 O(1)시간복잡도를 가집니다.(새 요소는 리스트의 시작 또는 끝에 삽입됨)<br>
삭제 시에는 O(N)이 걸립니다(전체 탐색)<br>
조회의 경우에도 O(N)의 시간복잡도를 가집니다.(전체 탐색)<br>
</details>

<details markdown = "1">
<summary>덱(deque)에 대해 설명해주세요</summary>
덱은 앞 뒤 모두 데이터의 삽입과 삭제가 가능한 자료구조입니다.이러한 덱은 큐와 스택을 모두 가지고있습니다.
양끝에서 모두 삽입,삭제가 가능하기에 사용자에게 유연성을 제공하고, 스택처럼 LIFO 동작, 큐처럼 FIFO 동작도 가능합니다.
</details>

<details markdown = "1">
<summary>hash와 hash Function이 무엇인지 설명해주세요</summary>
Hash란 일반적으로 key가 Hash Function을 통과하여 암호화되어 나온 결과물을 의미하고, Hash Function은 임의의 길이의 입력값을 <br>
고정 길이의 암호화된 출력으로 변환 해주는 함수를 뜻합니다.<br>
이러한 해시 함수는 어떤 입력 값에도 항상 고정된 길이의 해시값을 출력하고, 입력 값의 아주 일부만이 변경되어도 전혀 다른 결과값을 출력하는 특징을 가집니다.<br>
또한 출력된 결과값을 통해 입력값을 유추할 수 없다는 특징 또한 가집니다.<br>
<br>
꼬리질문 - 그러면 이런것들을 왜 사용할까요??
해시와 해시 함수는 데이터 관리를 훨씬 효율적으로 할 수 있게 도와줍니다. 해시 함수를 사용하면 원하는 데이터를 찾는데 필요한 시간을 줄일 수 있습니다.<br>
왜냐하면 해시함수는 특정 데이터를 고유한 고정된 길이의 해시값으로 변환하기에, 이 해시값을 사용해서 데이터를 바로 찾아갈 수 있기 때문입니다.<br>

예를들어 배열에서 특정 값을 찾으려면 보통 원하는 값을 찾을 때까지 배열의 모든 요소를 탐색해야 하므로 시간이 오래걸릴수 있습니다.<br>
하지만 해시 테이블을 사용하면 특정 키의 해시값을 계산하여 바로 해당 위치에 접근할 수 있으므로, 상대적으로 빠른 시간안에 원하는 값을 찾을 수 있습니다.<br>

또한 해시함수를 사용하면 데이터의 보안성을 높일수 있습니다. 일반적으로 해시 함수는 단방향성을 가지므로, 해시값을 통해 원래의 유추하는 것이 어렵습니다.<br>
이러한 특성 덕분에 해시 함수는 패스워드관리, 블록 체인 기술등 다양한 분야에서 활용되고 있습니다.<br>
</details>

<details markdown = "1">
<summary>해시 충돌이 무엇인지 혹시 아시나요?</summary>
해시 충돌이란 입력한 키 값이 다름에도 불구하고, 같은 해시값이 나오는 경우를 의미합니다.
</details>

<details markdown = "1">
<summary>이러한 해시 충돌은 불가피한것인가요??</summary>
일반적으로 해시 충돌은 불가피한 현상입니다. 저는 이 이유를 비둘기집 원리와 함께 설명드리고자 합니다.<br>
비들기집 원리는 간단히 말해서, 만약 n개의 비둘기집에 n+1마리의 비둘기가 있다면, 적어도 하나의 비둘기 집에는 두마리 이상의 비둘기가 있다는 원리입니다.<br>
해시함수의 경우, 일정한 크기의 해시 테이블에 많은 입력을 매핑해야 하는 상황에서 이 원리가 적용됩니다.<br>
즉, 한정된 수의 버킷에 무한히 많은 키를 매핑해야하는데, 이 경우엔 어떤 해시 함수를 사용하더라도 충돌은 불가피 합니다.<br>
물론, 실제로는 무한히 많은 키를 다루는 것은 아니지만, 주어진 입력 데이터의 가능한 모든 조합이 해시 테이블의 슬롯 수보다 많을 가능성이 높습니다.<br>
예를들어 문자열을 키로 사용한다고 가정해 보겠습니다. 문자열은 알파벳,숫자,특수 문자등 다양한 문자의 조합으로 이루어질 수 있고, 그 길이에도 제한이 없습니다.<br>
이렇게 가능한 조합이 거의 무한대에 가까운 데이터를 키로 사용할때, 이를 저장하기 위한 해시 테이블의 크기를 그만큼 무한대에 가까운크기로 만들 수 없습니다.<br>
따라서 해시 함수와 해시 테이블의 설계 과정에서 충돌을 최소화하는 것이 중요하며, 이를 효과적으로 처리하는 방법을 갖추는 것이 중요합니다.<br>
</details>

<details markdown = "1">
<summary>해시 충돌을 해결하는 방법에 대해 가능한 상세히 설명해주세요.</summary>
해시 충돌을 해결하는 대표적인 방법에는 개방 주소법(Open Address)과 분리 연결법이 있습니다.<br>
개방 주소법은 한 버킷당 들어갈 수 있는 엔트리는 하나이지만, 해시 함수로 얻은 주소가 아닌, 다른 주소에 데이터를 저장할 수 있도록 허용하는 방법입니다.<br>
충돌이 발생하는 경우 probing을 바탕으로 다음 slot을 찾아가는데 이러한 probing 방법에는 선형 탐사법, 제곱탐사법, 이중 해싱법 등이 있습니다.<br>
선형 탐사법이란 해시 충돌이 일어난 경우, 해당 해시값에서 고정된 폭만큼 옮겨 다음 빈칸을 찾는 방법입니다.<br>
이러한 방법은 로직을 구현하기엔 쉽지만, 테이블의 연속된 공간에 데이터가 몰리는 현상인 Primary Clustering이 발생합니다.<br>
이는 연속된 공간에 데이터가 몰리기 때문에, 같은 해시 값이 나오면 나올수록 탐색 효율이 계속 나빠집니다.따라서 해시 충돌이 해시 값 전체에 균등하게 발생할때는 유용한 방법입니다.<br>
그다음으로 제곱 탐사법은 선형 탐사법과 동일하나, 탐사 폭이 고정된 값이 아니라 제곱으로 늘어나는 점에서 차이가 있습니다.<br>
즉, 빈 버킷의 slot을 찾기 위해 고정된 값이 아니라 2의 1제곱,2제곱,3제곱 과 같은 방식으로 빈칸을 찾습니다.<br>
제곱 탐사법을 사용하면 데이터 밀집도가 선형 탐사법에 비해서는 낮기 다른 해시 값 까지 영향을 받아 연쇄적으로 충돌이 발생한 가능성이 적습니다.<br>
하지만 제곱 탐사법을 사용하면 데이터가 메모리 공간에 균등하게 분포되지 않고, 특정 제곱 값들(일부 공간)에만 값이 집중될수 있어, 선형탐사법보다는 캐시의 효율이 좋지 않습니다.<br>
즉 값의 분포(배열의 크기)가 넓어짐에 따라 Cache Hit ratio가 낮아집니다.<br> 
이중 해싱(재 해싱)방법은 충돌 시 항목을 저장할 다음 위치를 원래 해시 함수와 다른 별개의 해시 함수를 사용합니다.<br>
이 방법은 이전 방법에 비해 균일하게 데이터를 분포시킬 수 있습니다.(해시 함수 끼리 서로 달라야겠지?)<br>
이중 해싱 방법은 보통 로드 팩터가 높거나, 데이터의 분포가 매우 불균형할때 적합합니다.(충돌 또한 가장 적게 발생)<br>
하지만 두번째 해시 함수를 통해 새로운 해시값을 생성해서 추가 연산을 요구하게 되며, 이를 바탕으로 탐색 경로를 설정하기에, 빈 슬롯을 찾기 위해 메모리 내 여러 위치를 불규칙하게 접근하게 됩니다.<br>
즉 이러한 이중 해싱은 해시테이블의 여러 위치를 불규칙하게 접근하므로 캐시 최적화에 방해가 됩니다.<br>
이러한 이중 해싱법에 가장 큰 영향을 미치는 요소는 load factor입니다.(load factor가 클수록 선형이 가장 급격한 성능 저하)<br>
<br>
분리 연결법(Seperate chaining)은 개방 주소법과 달리 한 버킷당 들어갈 수 있는 엔트리 수에 제한을 두지 않는 방식입니다.<br>
이때 버킷은 보통 연결리스트를 사용합니다.<br> 해시 충돌이 만약 일어난 경우 리스트로 노드들이 연결되기에,데이터 개수에 제약이 적습니다.<br>
하지만 개방 주소법에 비해 추가적인 메모리 공간(다음 노드를 가리키는 포인터에 대한 공간)이 필요하며, Load Factor에 따라 선형적으로 성능이 저하됩니다.<br>
즉 로드 팩터가 증가하면 각 해시 버킷에 저장된 키-값 쌍의 수도 증가하기에, 특정 키를 찾는데 필요한 시간이 증가합니다.<br>
따라서 데이터가 적은 경우엔 일반적으로 개방 주소법이 평균적으로 더 빠릅니다.왜냐하면 개방 주소법은 충돌이 발생하더라도 추가적인 메모리 공간 없이<br>
원래 해시테이블 내에서 충돌을 해결하기 때문입니다.<br>
<br>
지금까지 설명드린 두가지 방법외에도, 해시 테이블의 Load Factor가 높은 경우엔 크기가 더 큰 새로운 테이블을 만들어 기존 데이터를 옮겨 사용하거나<br>
체이닝 방법을 통해 연결리스트가 너무 길어졌다면, 재해싱을 통해서 너무 길어진 리스트의 길이를 나누어 다시 저장하는 방법도 있습니다.<br>
<br>
참고 - 충돌이 일어나지 않는다면, 즉 각각의 키가 유일한 해시값을 가진다면, 탐색+삽입+삭제는 O(1)<br>
참고 - 체이닝으로 충돌을 해결하면, 원하는 키 값을 찾기 위해 인덱스의 모든 키 확인(탐색 및 삭제에 O(k : 키의 갯수))<br>
참고 - 개방 주소법으로 해결하면 탐색 및 삭제의 시간 복잡도는 로드 팩터(키의갯수 / 해시테이블 크기)에 비례합니다.<br>
로드 팩터가 증가할수록, 해시 테이블이 가득 차게 될 확률이 높으므로, 충돌 해결을 위한 프로빙 횟수가 증가!<br>
</details>

<details markdown = "1">
<summary>equals()와 hashCode() 메서드가 무엇인지 설명해주세요</summary>
두 메서드는 자바에서 객체의 동일성을 확인하는데 사용합니다.<br>
equals() 메서드는 Java에서 기본적으로 두객체의 메모리 주소를 비교하는 메서드입니다.<br>
하지만 객체의 내용을 비교하도록 equals() 메서드를 오버라이드 할 수 있습니다. 반면 hashCode() 메서드는<br>
객체의 메모리 주소를 기반으로 고유한 정수값을 반환합니다. 하지만 객체의 내용에 따라 동일한 해시코드를 반환하도록 <br>
hashCode() 메서드를 오버라이드 하는 것이 일반적입니다. 이렇게 함으로써 같은 내용의 객체가 해시 기반 컬렉션에서 같은 해시코드를 가지도록 할 수 있습니다.<br>
<br>
<br>
꼬리질문 - 이 둘을 왜 같이 사용하는지에 대해 예시와 함께 설명해주시겠어요?
저는 HashTable을 통해 예를 들어보겠습니다. 해시 테이블은 내부적으로 hashCode() 메서드를 이용하여 객체를 저장하고 검색하는 위치를 결정합니다.<br>
이때 hashCode() 메서드가 반환하는 값이 같다면, 이 두 객체는 같은 버킷에 위치하게 됩니다.<br>
그러나 hashCode가 같다고 이 두 객체가 항상 같은것은 아닙니다. 이는 해시 충돌 떄문인데, 서로 다른 두 객체가 동일한 해시코드를 가질 수 있기 때문입니다.<br>
이런 경우를 구분하기 위해 equals() 메서드를 사용하여 두 객체의 실제 내용을 비교합니다.<br>
<br>
따라서 equals() hashCode() 메서드는 항상 함께 오버라이드 해야합니다. 예를들어 equals() 메서드만 오버라이드 하고, hashCode() 메서드를<br>
오버라이드 하지 않는다면, 내용이 같은 두 객체의 해시코드가 다를 수 있어 해시 기반 컬렉션에서 예상치 못한 결과를 가져올 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>HashSet에 아시는 대로 설명해주세요.</summary>
HashSet은 Set인터페이스 구현체 중 하나입니다. HashSet은 중복된 요소를 허용하지 않는데, 이때 같음은 equals() 메서드와 HashCode() 메서드로 판단합니다.<br>
그리고 순서를 보장하지 않습니다.
이러한 HashSet은 내부적으로 HashMap을 사용하고, 각각의 요소들이 해시 함수를 통해 결정되는 버킷에 저장됩니다.<br>
따라서 특정 요소를 찾거나 추가하거나 삭제하는데, 상수시간이 걸립니다.<br>
하지만 해시 충돌이 발생한다면 O(n)의 시간복잡도를 가질수있습니다.(체이닝으로 해결 후 모든 요소가 동일한 버킷에 해시되는 경우)<br>
<br>
꼬리질문 - 왜 입력 순서가 보장되지 않을까요???
데이터 해싱된 값에 따라 저장되는 위치가 달라지기 때문에 순서가 보장되지 않습니다.<br>
만약 순서가 보장되어야 하는 상황이라면 LinkedHashSet을 사용하면 됩니다.<br>
<br>
참고 - hashCode()는 객체를 HashSet에 추가할때 해당 객체의 저장 위치 결정<br>
equals() 메서드는 해시 충돌이 일어날 때, 실제로 동일한 객체인지를 판별<br>
</details>

<details markdown = "1">
<summary>LinkedHashSet에 아시는 대로 설명해주세요.</summary>
linkedHashSet은 HashSet의 서브클래스로, 입력 순서에 따라 요소를 저장합니다.<br>
이는 HashSet과 달리 내부적으로 이중 연결 리스트를 유지하기 때문입니다.<br>
그 외에는 HashSet과 유사하게 중복된 요소를 허용하지 않고, equals()와 hashCode() 메서드를 통해 동일성을 결정합니다.<br>
<br>
참고 - 노드 내부에 다음 노드와 이전 노드를 가리키는 변수가 있다.
</details>

<details markdown = "1">
<summary>TreeSet에 아시는 대로 설명해주세요.</summary>
TreeSet은 Set인터페이스 구현체 중 하나로 HashSet,LinkedList와 같이 중복을 허용하지 않습니다.<br>
이러한 TreeSet의 가장 중요한 특징 중 하나는 자동 정렬기능입니다. TreeSet에 요소를 추가하면, 요소는 자연 순서 또는 TreeSet을 생성할때 제공한 Comparator에 따라 자동정렬됩니다.<br>
방금 말한 자연 순서란 요소가 Comparable 인터페이스를 구현하고 있는 경우 해당 객체 compareTo 메서드를 통해 결정됩니다.<br>
TreeSet은 내부적으로 레드 블랙 트리라는 자료 구조를 사용합니다.<br>
따라서 추가,삭제,검색 작업은 모두 log(n)의 시간복잡도를 가집니다. 이는 정렬된 상태를 유지하면서 이러한 연산을 수행하는 경우에 유용합니다.<br>
참고 - 비동기화 되어있음 유의, 삽입 및 삭제 시 트리의 균형을 유지하기 위한 재배치가 필요
</details>

<details markdown = "1">
<summary>BST(Binary Search Tree, 이진탐색트리)와 Binary Tree(이진트리)에 대해 설명해 주세요.</summary>
이진 탐색 트리란 이진 트리의 일종으로, 특정한 규칙에 따라 데이터를 저장하는 구조입니다.<br>
각 노드의 왼쪽 서브트리에는 현재 노드의 값보다 작은 값들을, 오른쪽 서브트리에는 현재 노드의 값보다 큰 값들을 저장하는 방식으로 작동합니다.<br>
이러한 방식 덕분에 이진탐색 트리에서는 일반적으로 데이터 검색,삽입,삭제 등의 작업을 로그 시간 내에 처리할 수 있습니다.(편향된 경우엔 O(N))<br>
<br>
하지만 이진 탐색 트리는 데이터가 이미 정렬되어있거나(12345 순으로 삽입한다고 생각해보자), 특정 패턴을 따라 삽입되는 경우 트리가 한쪽으로 치우쳐진 편향트리가 될 수 있습니다.<br>
이런 경우 트리의 높이가 높아져서 탐색,삽입,삭제 등의 연산이 O(N)에 비례합니다.<br>
따라서 이진 탐색 트리를 사용할때는 이런 문제를 고려해야 하면 이를 보완하기 위한 트리로 AVL 트리나 레드블랙 트리같은 균형 이진 탐색 트리가있습니다.<br>
<br>
반면 이진 트리는 모든 노드가 최대 두개의 자식 노드를 가지는 트리 구조를 말합니다.<br>
이러한 이진 트리는 빠른 데이터 삽입,삭제,검색이 가능하며, 이러한 연산은 보통 O(N)의 시간복잡도를 가집니다.<br>
이러한 이진트리는 대개 정렬되지 않은 데이터를 저장하거나, 이진 탐색이 아닌 다른 트리 기반 알고리즘을 구현할때 사용합니다.<br>
또한, 트리의 높이(height)를 최소화하여 효율적인 탐색을 할 수 있도록 균형 잡힌 트리(balanced tree)를 사용하는 경우도 있습니다. 대표적인 균형 잡힌 트리로는 AVL 트리, Red-Black 트리 등이 있습니다<br>
참고 - 중위 순회 방식으로 정렬된 순서대로 읽을 수 있음.
<br><br>
꼬리질문 - 둘의 차이점에 대해 설명해주세요.<br>
둘다 트리의 형태를 가진 데이터 구조이지만, 그 구조와 사용 방식에서 차이점이 있습니다.<br>
이진 트리는 각 노드가 최대 두개의 자식 노드를 가질수 있는 트리 데이터 구조입니다.<br>
이진 트리에서 노드는 특별한 순서로 배열되지 않습니다. 이는 이진 트리에서의 데이터 검색,삽입,삭제 연산이 효율적이지 않을 수 있습니다.<br>
이러한 이진 트리는 주로 트리 순회나 트리 기반 알고리즘의 구현 등에 사용합니다.<br>
반면 이진 탐색 트리는 이진 트리의 한 종류이지만, 데이터가 특정한 순서를 따라 배열됩니다. 모든 노드는 왼쪽 서브 트리의 노드들보다 크고 오른쪽 서브 트리의 노드들 보다 작습니다.<br>
이러한 특성으로 인해 연산을 효율적으로 수행할 수 있습니다.<br>
그러나, 이러한 성능은 트리가 균형이 잡혀있는 경우에만 보장됩니다.<br>
즉 요약하자면, 주요 차이점은 데이터의 정렬 상태에 있습니다.<br>
참고 - 이진 트리는 모든 노드를 방문해야 할 수 있겠지???
<br><br>
꼬리질문2 - 이진 탐색 트리의 연산 과정들에 대해 설명해주세요.<br>
이진 탐색 트리에서 검색 연산은 루트 노드에서 시작합니다.<br>
검색하려는 값이 루트 노드의 값보다 작으면 왼쪽 서브트리로, 크면 오른쪽 서브트리로 이동합니다.이 과정에서 검색하려는 값이 나타날때까지 반복합니다.<br>
삽입 연산 또한 루트 노드에서 시작하며, 삽입하려는 값이 루트 노드의 값보다 작으면 왼쪽, 크면 오른쪽으로 이동합니다.<br>
이 과정을 적절한 위치를 찾을때까지 반복합니다.<br>
삭제의 경우에는 삭제하려는 노드를 찾은후, 그 노드가 자식노드를 가지고 있는지 확인합니다.<br>
이때 리프노드라면 그냥 삭제하고, 하나의 자식 노드가 있으면 삭제하려는 노드를 제거하고 그 자식 노드를 삭제된 노드의 부모 노드로 연결합니다.<br>
그리고 두개의 자식 노드가 있으면 삭제할 노드의 오른쪽 서브트리에서 가장 작은 값이나 또는 왼쪽 서브트리의 가장 큰 값을 찾아 교체하게됩니다.<br>
참고 - 자식 두개 일때 BST 특성을 유지하기 위해 위와 같이 진행<br>
<br>
</details>
<details markdown = "1">
<summary>AVL 트리와 Red Black 트리에 대해 설명해주세요</summary>
AVL 트리와 Red black 트리 모두 BST의 단점인 트리의 불균형을 해결하기 위해 고안된 자료구조로 트리의 균형을 맞추어 탐색시간을 최소화하는데 사용됩니다.<br>
탐색 시간을 O(log N)으로 유지하면서 삽입,삭제 연산을 효율적으로 처리할 수 있도록 개발된 자료구조입니다.<br>
이진 탐색 트리는 탐색이나 삽입,삭제 연산시 평균적으로 O(log N)의 시간복잡도를 보입니다.<br>
그러나 트리의 구조가 한쪽으로 치우쳐져 있거나, 노드의 갯수가 많아질수록, 탐색 시간이 더욱 증가할 수 있습니다.<br>
이러한 문제를 해결하기 위해 AVL 트리와 Red-Black 트리가 개발되었습니다.<br>
AVL 트리는 모든 노드의 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 1이하인 트리를 의미합니다.<br>
이러한 트리 구조를 유지하기 위해 삽입,삭제 연산시에는 회전(rotate)연산을 이용해 트리의 균형을 맞추어줍니다.<br>
Red-Black 트리는 AVL 트리보다 균형을 덜 맞춘 대신, 노드의 색깔을 이용하여 트리의 균형을 유지하는 BST입니다.<br>
레드 블랙 트리는 모든 노드가 레드 또는 블랙 중 하나의 색깔을 가지도록 구성되며, 일정한 규칙에 따라 노드를 삽입,삭제 하며 균형을 유지하며 다음과 같은 규칙을 따릅니다.<br>
루트 노드는 블랙이다, 모든 리프 노드는 블랙, 레드노드의 자식 노드는 모두 블랙, 어떤 노드에서 루트 노드까지 경로상에 있는 블랙 노드의 수는 모두 같다.<br>
이러한 규칙을 통해 red-black 트리는 균형을 맞추면서도 AVL트리보다 회전 연산의 발생 횟수가 적어 더욱 효율적인 탐색이 가능합니다.<br>
이러한 레드블랙 트리의 탐색 시간은 O(log N : 편향트리가 안되게끔 균형을 유지하므로)입니다.<br>
<br>
AVL 트리와 Red-Black 트리중 어떤 경우에 어떤 트리를 사용하면 좋을까요?<br>
AVL 트리는 트리의 높이를 균형 잡히게 유지하기때문에 탐색 중심의 연산이 많은 경우 유리합니다.<br>
반면 Red-Black 트리는 삽입과 삭제가 빈번히 일어나는 경우 유리합니다.왜냐하면 Red-Black 트리는 AVL 트리에 비해 리밸런싱 연산이 덜 발생하기 때문입니다.<br>
위 질문에 대한 추가질문 나올시<br>
AVL 트리는 자식 노드들 간의 높이가 최대 1이 되도록 유지하는 자료구조입니다.즉 트리의 균형을 비교적 엄격하게 유지합니다.<br>
이러한 특성때문에 AVL 트리는 깊이가 작고, 탐색 연산에 있어 효율적입니다.<br>
하지만, 이러한 엄격한 균형 유지로 인해 삽입,삭제 시 발생할 수 있는 회전연산이 빈번히 발생합니다.<br>
반면 AVL 트리는 노드 색상을 이용하여 트리의 균형을 부분적으로만 유지합니다.<br>
즉 AVL트리에 비해 균형 조건이 덜 엄격하고, 리밸런싱 연산이 덜 빈번하게 발생합니다.<br>
하지만 AVL트리에 비해 트리의 높이가 조금 더 높아질수있어, 탐색 연산이 AVL트리보다 조금 덜 효율적일순 있습니다.<br>
<br>
참고 - (자가)균형 이진 트리란 모든 노드에 대해 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 특정 값 이하면 이진 트리를 의미합니다.(AVL,REd-black)<br>
균형 이진 트리의  목적은 트리의 높이를 최소화하여 연산의 효율성을 보장하는 것입니다.<br>
</details>

<details markdown = "1">
<summary>레드 블랙 트리에 대해 아시는 한 상세히 설명해주세요.</summary>
레드 블랙 트리는 이진 탐색 트리의 확장 개념으로, 어떠한 연산이 일어나더라도 상대적으로 균형을 유지하는 특성이있습니다.<br>
레드블랙 노드는 총 5가지의 규칙을 가지고있습니다.<br>
첫번째로 각 노드는 레드 혹은 블랙이라는 색을 가지며, 이 색 정보는 노드 균형 유지를 위해 사용됩니다.<br>
두번째로 트리의 루트노드는 항상 블랙입니다.세번째로 모든 리프노드(null또는 NIL 노드)는 블랙입니다.<br>
네번째로 레드 노드의 자식은 언제나 블랙입니다. 즉 레드 노드가 연속으로 등장할수 없습니다.<br>
마지막으로 모든 노드에 대해 해당 노드로부터 자손인 리프 노드에 이르는 모든 경로에는 동일한 개수의 블랙 노드가 있습니다.<br>
또한 특성에 대해 조금더 설명드리자면, 루트 노드부터 리프노드까지의 모든 경로 중 최소 경로와 최대 경로의 크기비율은 2보다 크지 않습니다.(ex: 검검검, 검빨검빨 ....)<br>
이러한 상태를 balanced 상태라고 합니다.<br>
그리고 노드의 자식이 없는 경우, 자식 노드를 가리키는 포인터에 NIL 값을 저장하고 이를 리프노드이며, 검정색으로 간주하여 규칙(마지막 규칙)을 유지하게 됩니다.<br><br>
삽입 연산시에는 값을 삽입하다보면 Double Red가 발생할수있습니다.(일반적으로 삽입되는 노드는 레드 생각으로 설정) <br>
이때 엉클노드 즉 부모의 형제노드가 검정이면 Restructing, 빨강이면 Recoloring을 진행하게 됩니다.<br>
Restrucing은 현재 인서트된 노드, 그 노드의 부모노드, 조부모 노드를 가지고 진행합니다.<br>
이때 세 노드를 오름차순으로 정렬 후, 가운데 값을 부모로 만들고 나머지 둘을 자식으로 하게됩니다.<br>
이후 가운데 값을 검정, 나머지 두 자식을 빨강색으로 하게됩니다.<br>
이는 다른 서브트리에 영향을 끼치지 않아 한번에 Restrucint이면 끝나게 됩니다.(이러한 연산 진행 시 더블레드 해결 전후의 black 노드의 갯수 변화가 없으므로)<br>
또한 자체 시간 복잡도는 O(1)에 끝나지만(순서 결정 - 상수, 트리로 만드는- 상수, 노드 구조바꾸기 - 상수) 어디에 삽입될지 위치를 찾아야 하므로 수행시간은 O(log N)입니다.<br>
리 컬러링은 현재 인서트된 노드의 부모와 그 형제를 검정으로 하고 조부모를 빨강으로 합니다.<br>
이때 조부모가 루트노드가 아니고, 서브트리인 경우 더블레드가 발생할 수 있기에 여러번 진행 될 수 있습니다.<br>
연산 자체는 O(1)이지만, root까지 연산이 계속될수 있기에 최악의 경우 log(N)입니다.
이러한 규칙을 통해 레드-블랙 트리는 삽입,삭제 연산이 일어날때 트리의 균형을 유지하게 됩니다.<br><br>
삭제의 경우에는 그 노드가 레드 색상일 경우는 제거해도 균형 규칙을 위반하지 않기에 간단히 삭제해도됩니다.<br>
그러나 삭제 노드가 블랙인 경우에는 균형을 재조정해야합니다. 블랙 노드를 삭제하면 그 경로에 있는 블랙 노드 숫자가 줄어들어 규칙에 위반하기 때문입니다.<br>
이를 위해 삭제된 블랙 노드의 자리를 차지하는 노드의 색을 블랙으로 변경합니다.<br>
그런데 이때 새로운 노드가 이미 블랙이였다면,이중 흑색 노드가 되어 따로 처리를 해야 합니다.<br>
이때 형제 노드가 레드 노드이면, 형제 노드를 블랙, 부모 노드를 레드로 변경후, 부모 중심으로 왼쪽 회전을 합니다.<br>
형제노드가 블랙이고, 형제 양쪽 자식이 모두 블랙인 경우, 이중 블랙 노드에서 블랙하나를 제거하고, 형제 노드를 레드로 변경한 후, 부모 노드에 블랙을 추가합니다.<br>
형제 노드가 블랙이고, 형제 노드의 왼쪽 자식은 레드, 오른쪽 블랙인 경우, 형제 노드를 레드로, 형제 노드의 왼쪽 자식을 블랙으로 변경후, 형제 노드 중심으로 오른쪽 회전합니다.<br>
형제 노드가 블랙이고, 형제 노드의 오른쪽 자식은 레드인 경우, 부모 노드의 색을 형제에게 넘기고, 부모는 검, 형제 노드의 오른쪽 자식은 검으로변경 후 부모 기준 좌회전을 합니다.<br>
이러한 삭제 연산은 O(log N)의 시간복잡도를 가집니다.<br>
왜냐하면 레드 블랙트리는 균형 이진 탐색 트리의 한종류이기에, 높이가 log N을넘지 않습니다.<br>
삭제 연산은 탐색,삭제 및 앞서 말한 밸런싱 과정을 거치는데, 탐색 및 삭제는 log N의 시간복잡도를 가지며, 재 균형화 작업은 상수 시간 복잡도(루트 까지 반복되는 경우 이또한 log(N)를 가집니다.<br>
따라서 삭제 연산의 시간복잡도는 O(log N)입니다.<br>
<br>
참고 - 리컬러링에서 부모랑 엉클을 검정으로막 바꿔도되나? - 바꿔도 black depth는 일제히 1 증가하기에 문제 없습니다.<br>
</details>

<details markdown = "1">
<summary>트리와 그래프에 대해 설명해주세요.</summary>
둘다 복잡한 객체 간의 관계를 표현하는데 사용하는 자료구조입니다.<br>
트리는 계층적인 구조를 가지는 그래프의 일종입니다.<br>
트리는 루트 노드라 불리는 최상위 노드가 존재하며, 그 아래로 다수의 자식 노드가 붙어있는 형태입니다<br>
즉 부모 노드에서 자식 노드로의 방향성이 있습니다.<br>
이러한 트리는 사이클이 없습니다.즉 어떤 노드에서 출발하여 자신으로 다시 돌아오는 경로가 존재하지 않습나.<br>
그리고 두 노드를 잇는 경로는 유일하다는 특징을 가집니다.<br>
반면 그래프는 트리보다 더 일반적인 구조를 가집니다.<br>
그래프는 노드(or 정점:vertex)와 이들을 연결하는 간선으로 구성됩니다.(간선은 방향성을 가질수도 가지지 않을수도)<br>
요약하자면, 모든 트리는 그래프이지만, 모든 그래프가 트리인것은 아닙니다.<br>
트리는 순환없이 연결된 그래프의 특별한 형태로, 계층적인 구조를 가지나, 그래프는 좀더 일반적인 집합으로, 순환이나 다중 경로를 포함할 수 있습니다.<br><br>
참고 - 트리 용어 정리<br>
노드 : 트리의 핵심적인 구성 요소로, 정보를 저장, 그래프의 꼭짓점<br>
루트 : 트리의 가장 상위에 위치하는 노드로, 부모 노드가 없는 최상위노드<br>
자식 : 어떤 노드 아래, 부모 : 어떤 노드 위<br>
자손 노드 : 어떤 노드에서 리프 노드에 이르는 경로에 포함된 모든 노드<br>
조상 노드 : 루트 노드에서 어떤 노드에 이르는 경로에 포함된 모든 노드<br>
Leaf Node,Terminal Node : 자식 없는 노드<br>
내부 노드(Internal Node : 중간노드) : 루트 노드나 리프 노드가 아닌 로드<br>
간선 : 노드와 노드 연결하는 선<br>
형제 : 같은 부모를 가지는 노드를 형제 노드 라고함<br>
레벨 : 트리에서 루트 노드가 위치한 곳을 레벨0이라고 하고, 아래로 갈수록 1씩 증가<br>
깊이(depth) : 자신을 제외한 조상 노드의 갯수<br>
높이 : 트리의 높이는 루트 노드에서 가장 멀리 떨어지느 노드의 레벨 : 트리의 최대 레벨<br>
노드의 높이 : 해당 node가 리프 노드면 0이며, 해당 노드의 자식들의 height 중 가장 높은값 + 1<br>
차수 : 트리의 노드가 가지고 있는 자식의 노드 수를 의미<br>
</details>

<details markdown = "1">
<summary>트리를 순회하는 방법에 대해 아시는대로 설명해주세요.</summary>
트리를 순회하는 방법에는 주로 전위(inOrder)순회, 중위 순회(inorder), 후위 순회(post-order)가 있습니다.<br>
이 방법들 모두 트리의 모든 노드를 한번씩 방문하지만, 방문하는 순서에서 차이를 보입니다.<br>
전위 순회란 루트 노드를 먼저 방문하고, 그다음 왼쪽 서브트리를, 마지막으로 오른쪽 서브트리를 순회합니다.<br>
중위 순회는 왼쪽 서브트리를 먼저 순회하고, 그다음 루트 노드를 방문 한 후, 마지막으로 오른쪽 서브트리를 순회합니다.<br>
후위 순회는 왼쪽 서브트리를 먼저 순회하고, 그다음 오른쪽 서브트리를 순회한후, 마지막으로 루트 노드를 방문합니다.<br>
이 외에도 level-order 순회가 있습니다. 이는 트리의 노드를 레벨 순서대로, 각 레벨내에서는 왼쪽에서 오른쪽으로 방문합니다.(보통 큐로)<br>
</details>

<details markdown = "1">
<summary>HashTable과 HashMap 무엇인지 말씀해주세요.</summary>
HashTable이란 키-값 쌍으로 데이터를 저장하는 자료구조중 하나입니다.해시 충돌이 발생하지 않은 경우 데이터의 조회, 삽입, 삭제 등의 작업을 상수시간(충돌시:O(N))에 처리할 수 있어 자주 사용하는 자료구조입니다.
HashTable의 핵심 원리는 Hashing입니다. 해싱을 통해 키를 바탕으로 값을 빠르게 찾을 수 있습니다.<br>
이러한 해싱시에는 다른 값임에도 같은 해시 값을 가지게 되는 해시 충돌이 발생할 수 있습니다.<br>
자바에서는 hash를 사용하는 collection들의 해시 충돌을 해결하기 위해 체이닝 방법을 사용합니다.(임계점 넘으면 리해싱도 진행)<br>
즉 open Address 방식과 같이 다른 공간을 찾아 저장하는 것이 아니라, 해당 버킷에 LinkedList를 추가하여 충돌을 처리합니다.<br>
이러한 해시테이블은 HashMap과 동기화 지원 여부 및 null값 허용 여부에서 차이를 보입니다.<br>
HashMap에서는 null값을 허용하지만 HashTable은 null키나 값이 있으면 NPE를 던집니다.<br>
또한 HashMap은 동기화 처리가 되어있지 않아 멀티 스레드 환경에서 사용할 때 Thread Safe 하지 않은 반면, HashTable은 자체적으로 동기화 기능을 제공하기에, 멀티 스레드 환경에서도 안정적으로 사용할 수 있습니다.<br>
하지만 단일 스레드 환경에서는 동기화가 필요없기에 HashMap이 HashTable보다 더 빠른 성능을 제공합니다.<br>
동기화를 위한 오버헤드가 발생하지 않으며, 자바 8이후로 HashMap은 LinkedList의 크기가 임계값을 넘으면 밸런스 트리로 바꾸는 변경사항을 적용하여 성능이 더욱 향상되었습니다(O(n) -> O(log N).<br>
<br>
꼬리질문1 - 그렇다면 멀티쓰레드 상황에서는 HashTable을 사용하는 것이 가장 바람직한가요?
HashTable은 메서드가 동기화 되어있으므로, 한번에 하나의 쓰레드만이 HashTable의 메서드를 사용할 수 있습니다.<br>
이는 공유 자원에 대한 동시 엑세스를 방지하지만 성능에 대한 오버헤드가 발생합니다.<br>
하지만 ConcurrentHashMap은 HashTable과 달리 내부적으로 여러개의 bucket(segment)를 가지며, 각 Segment별로 잠금 처리가 되어 동시에 여러 스레드가 작업을 수행할 수 있습니다.(해시 테이블 개선 버전)<br>
즉, ConcurrentHashMap은 동시에 여러 스레드가 데이터를 읽거나 쓸 수 있도록 허용하므로, 동시성 환경에서 성능 향상을 가져옵니다.<br>
따라서 동시성 환경이라면 HashTable 보다 ConcurrentHashMap을 사용하는 것이 성능적으로 더 좋습니다.<br>
<br>
참고 - 멀티스레드 환경이지만 동시에 매우 적은 수의 스레드만 접근한다면 hashtable이나 hashmap이 더 작합할 수 있음<br>
<br>
꼬리질문2 - 결국 데이터가 많아지면, 다른 데이터가 같은 해시 값으로 충돌 나는 현상이 발생하는데도 해시 테이블을 사용하는 이유는 무엇인가요?
먼저, 데이터의 양이 증가하면서 해시 충돌의 가능성이 증가하는 상황에서도 해시 테이블이 유용한 이유는, 여전히 평균적으로 빠른 조회 속도를 제공하기 때문입니다<br>
물론, 해시 충돌이 발생하면 성능이 저하될 수 있지만, 이러한 충돌을 최소화하는 해시 함수의 선택과 충돌이 발생했을 때 이를 해결하는 기법(예: 체이닝 또는 개방주소법 등)을 통해 성능 저하를 최소화할 수 있습니다.<br>
두 번째로, 해시 테이블은 크기가 제한된 공간에서 효율적인 데이터 관리를 가능하게 합니다. 즉, 용량이 큰 데이터 집합을 상대적으로 작은 공간에 매핑하여, 공간 효율성을 극대화합니다. 이는 데이터베이스 시스템, 캐시 메모리와 같이 공간의 제약이 있는 상황에서 매우 중요한 특성입니다<br>
결국, 해시 테이블의 선택은 데이터의 양, 공간 효율성, 그리고 성능 사이에서의 트레이드오프를 고려해 결정됩니다. 충돌의 가능성에도 불구하고, 해시 테이블은 이러한 여러 요소를 적절히 조합하여 매우 효율적인 데이터 구조를 제공하기 때문에 널리 사용되고 있는 것입니다<br>
<br>
참고 - 예를들어 10만개의 데이터가 있고,이중 john이라는 이름을 가진 사람을 찾고 싶다고 하자.<br>
배열에서 john을 찾기 위해서는, 첫번째 부터 마지막 요소까지 하나하나 확인(O(N))<br>
반면 해시테이블에서는 John이라는 키가 이미 저장되어있으며, 해당 키에 대응하는 값을 해시 함수를 통해 계산된 인덱스에 저장되어있음.<br>
따라서 즉시 해당 값을 찾아낼 수 있다. 즉 둘의 차이는 값을 어떻게 찾느냐에 따라 다르다.
<br><br>
꼬리질문3 - 동기화된 자료구조란 무엇인가요?<br>
이것은 멀티스레드환경에서 안전하게 사용할 수 있는 자료구조입니다.<br>
멀티스레드 환경에서 여러 개의 스레드가 동시에 접근하면 데이터 불일치가 발생할 수 있습니다.이를 위해 동기화된 자료구조를 사용합니다.<br>
동기화된 자료구조는 일반적으로 락이라는 동기화 기술을 사용하여 여러 스레드가 동시에 접근할 수 없도록 막습니다.<br>
하지만 동기화된 자료구조를 사용하면 락을 획득하고 반납하는 과정에서 오버헤드가 발생하므로, 성능에 영향을 미칩니다.<br>
따라서 가능하면 스레드 안전하지 않은 자료구조를 사용하는 것이 좋을 수 잇찌만, 이 경우에는 스레드간 접근을 제어하기 위한 다른 방법을 사용해야합니다.<br>
<br>
참고<br>
hashmap - 삽입(평균 1, 최악의 경우 logn(자바8 이후)), 조회(평균 1: 최악의 경우 log n)), 삭제(1, log n)<br>
hashtable - 삽입(평균 1, 최악의 경우 n), 조회 삭제 다 같음<br>
linkedHashMap : hashmap과 같음<br>
TreeMap : 삽입,조회,삭제 (log n)<br>
</details>

<details markdown = "1">
<summary>LinkedHashMap과 TreeMap에 대해 설명해주세요.</summary>
LinkedHashMap은 순서를 고려하는 HashMap의 확장형입니다. 기본적인 HashMap의 특성을 가지면서도, 원소들이 추가된 순서에 따라 이중 연결 리스트로 연결되어 있습니다<br>
이 특성 덕분에 입력 순서가 중요한 상황에서, 예를 들어 최근에 입력된 원소에 빠르게 접근하거나 원소를 순차적으로 처리해야 하는 상황에 적합합니다.<br>
하지만, 이런 순서 정보를 저장하기 위해 추가적인 메모리를 사용하므로, 공간 효율성이 중요한 상황에서는 주의해야 합니다.<br>
반면에 TreeMap은 키-값 쌍을 Red-Black 트리 구조로 저장하는 구현체입니다. 이 트리의 균형 유지 속성 때문에, 삽입, 조회, 삭제 연산에 O(log N)의 시간 복잡도를 가집니다.<br>
특히, TreeMap은 키를 기준으로 자동 정렬하는 기능을 제공하므로, 키에 따른 순서가 중요한 상황에서 유용하게 사용될 수 있습니다. 다만, TreeMap은 동기화를 지원하지 않으므로, 멀티 스레드 환경에서 사용할 때는 주의해야 합니다.<br>
</details>

<details markdown = "1">
<summary>제네릭이 무엇이고 어떨때 사용하나요??</summary>
제네릭이란 클래스나 메서드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방식입니다.<br>
이러한 제네릭은 타입 안정성을 보장합니다.즉 제네릭을 사용하면 컴파일 시점에 타입 체크가 가능하므로, 실행 시 불필요한 타입 변환을 방지하고, 잘못된 타입의 객체가 저장되는 것을 막을 수 있습니다.<br>
또한 제네릭을 사용하면 하나의 코드를 다양한 타입에 대해 사용할 수 있기에 코드 재사용성이 좋아집니다.<br>
예를들어 List인터페이스를 구현하는 ArrayList 클래스는 다양한 타입의 객체를 저장할 수 있게끔 제네릭을 사용합니다.(특정 타입에 종속되지 않는 유연한 코드 작성)<br>
<br>
참고 - 예를들어 ArrayList에 제네릭을 지정하지 않으면 "hello"도 저장가능하고 1도 저장가능함<br>
이는 Object 형식으로 반환을 하는데 String text = (String)list.get(1)이라고 하면 ClassCastException이 발생할 수 있음<br>
하지만 제네릭을 사용하면 컴파일 시점에 오류가 나기에 list.add(1)은 가능하지 않음<br>
<br>
꼬리질문 - 와일드카드가 무엇인지 아시나요??<br>
와일드 카드란 제네릭 타입에 다형성을 적용하고자 할때 사용하는 개념입니다.<br>
이것은 ?를 사용하는데, 이때 extends를 통해 와일드 카드의 상한 제한(T와 그 자손만), super를 통해 와일드 카드의 하한 제한(T와 그 조상들만 가능)을 할 수 있습니다.<br>
이러한 와일드 카드를 이용하면 하나의 참조변수로 다른 타입의 지네릭 타입이 지정된 객체를 다룰 수 있습니다.<br>
<br>참고<br>
ArrayList<? extends Product> list = new ArrayList<TV>() or new ArrayList<Audio>()
</details>

<details markdown = "1">
<summary>애너테이션이 무엇인지 설명해주세요.</summary>
애너테이션이란 프로그램에게 정보를 제공하는 주석을 뜻합니다.<br>
이러한 애너테이션에는 자바에서 기본적으로 제공하는 표준어노테이션(@Override, @Deprecated)와 다른 어노테이션에 대한 정보를 제공하는 메타 에너테이션이 있으며,<br>
사용자가 직접 정의를 하여 사용할 수 있습니다.<br>
이러한 애너테이션을 사용하여 롬북과 같이 프로그램 작성시 코드를 자동 생성하도록 정보를 제공할수도 있고, 런타임에 특정 기능을 실행하도록 정보를 제공할 수 있습니다.(@Transactional)<br> 
</details>

<details markdown = "1">
<summary>JDK, JRE, JVM란 무엇인지 설명해주세요.</summary>
JDK(Java Development Kit)이란 Java 언어로 소프트웨어를 개발하기 위한 소프트웨어 개발 도구 모음을 뜻합니다.<br>
이러한 JDK에는 자바 개발시 필요한 라이브러리들과, java compiler(자바 코드 -> 바이트 코드)과 jar(java 클래스 파일을 하나의 아카이브 파일로 패키징)와 같은 개발 도구들이 포함되어있습니다.<br>
그리고 자바 프로그램을 실행시키기 위한 JRE(Java Runtime Environment)또한 포함되어있습니다.(라이센스에 따라 여러 JDK 종류가 있음)<br>
JRE는 Java 응용 프로그램을 실행하는 데 필요한 최소 환경을 뜻하며 여기에는 클래스 라이브러리, JVM(Java Virtual Machine) 및 배포 도구가 포함됩니다.(이러한 소프트웨어 구성 요소를 사용하여 모든 디바이스에서 바이트 코드를 실행합니다.)<br>
JVM은 Java Virtual Machine의 약자로, 자바 바이트 코드를 실행하는 소프트웨어를 의미합니다.<br>
이러한 JVM은 바이트 코드를 해당 OS나 하드웨어 아키텍처에 알맞은 기계어로 해석 또는 실행해주기에, 플랫폼(운영체제)에 관계 없이 독립적으로 프로그램을 실행할 수 있습니다.<br>
<br>
참고 - 바이트코드란 특정 하드웨어가 아닌 가상 머신에서 실행되도록 고안된 특별한 형태의 중간 코드<br>
기계어란 컴퓨터의 CPU가 직접 이해할 수 있는 저 수준의 언어(CPU에 따라 각각 인스트럭션 셋이라고 하는 기계어 명령어 세트를 가짐)<br>
java C에 비해 JVM을 거쳐야 하길래 상대적으로 느림<br>
간단히 자바 컴파일 과정 - 자바 소스코드(.java)는 자바 컴파일러에 의해 바이트코드(.class 파일)로 변환됨. 이렇게 생성된 바이트 코드는 JVM 위에서 실행되는 동안, JVM 내부의 인터프리터에 의해 해당 시스템의 기계어로 해석된 후 실행됨<br>
하지만 인터프리터는 모든 코드라인을 읽으면서, 중복된 코드에 대해서도 매번 다시 읽음<br>
이러한 인터프리터 단점을 극복하기 위해 JIT(Just-in-Time) 컴파일러도 함께 사용함(자주 사용되는 코드 캐싱하여 빠름)<br>
자바 개발 도구인 JDK를 이용해 개발된 프로그램은 JRE에 의해 가상의 컴퓨터인 JVM 상에서 구동됩니다.
</details>

<details markdown = "1">
<summary>자바 프로그램 동작 방식에 대해 설명해주세요(or JVM 동작 방식)</summary>
![](cs-study/images/스크린샷 2023-05-31 오후 3.28.23.png)
</details>