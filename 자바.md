# 자바

<details markdown = "1">
<summary>기본형과 참조형이 무엇인지와 그에 대한 차이를 설명해주세요.</summary>

자바에서는 총 8가지의 기본형 타입(byte, short, int, long, float, double, char, boolean)을 미리 정의하고 제공해줍니다.<br>
기본형 변수는 메모리의 스택 영역에 할당되며, 값이 저장될때 해당 메모리 위치에 직접 저장됩니다.<br>
참조형 타입에는 클래스, 인터페이스, 배열 등이 있습니다. 참조형 변수는 메모리의 스택 영역에 할당되며, 객체는 힙 영역에 할당됩니다.<br>
이때 참조형 변수는 힙 영역에 저장된 객체의 주소를 가리키고 있는 것이 특징입니다.
</details>

<details markdown = "1">
<summary> 자바에서 '=='연산자와 'equals()' 메서드의 차이에 대해 설명해주세요 </summary>

두 변수가 같은 객체(같은 메모리 공간)를 가리키는지 확인하려면 ==를 사용하고, 객체의 내용 자체가 동일한지 확인하려면 equals()를 사용해야 합니다. <br>
기본형 변수의 경우 ==를 사용하면 됩니다. 하지만 참조형 변수의 경우, 특히 문자열이나 사용자 정의 클래스와 같은 객체를 비교할 때는 equals() 메서드를 사용하는 것이 좋습니다.<br>
참고: equals는 override 할 수 있기 때문에 사용자가 원하는 논리적인 통일성을 비교할 수 있다.<br>
참고 : equals는 주소 값을 자체를 비교하는 것은 아니지만 주소값을 통해서 비교를 함
</details>

<details markdown = "1">
<summary> call by reference 와 call by value의 차이에 대해 설명해주세요.</summary>

call by value와 call by reference는 함수 호출 시 인자 전달 방식의 차이를 나타냅니다.<br>
call by value는 함수에 인자를 전달할때 값을 넘겨받은 메소드에서
값을 복사하여 새로운 지역 변수에 저장하는 방식입니다. 이 경우, 함수 내에서 인자 값이 변경되더라도 원래 변수에는 영향을 미치지 않습니다.<br>
반면 call by reference는 함수에 인자를 전달할때 변수의 주소를 전달하는 방식입니다. 이 경우 함수 내에서 인자 값이 변경되면 원래 변수의 값도 함께 변경됩니다.<br>
자바에서는 기본형 변수를 함수의 인자로 전달할때 call by value 방식을 사용하고, 참조형 변수를 전달할때는 call by reference의 개념과 유사한 방식을 사용합니다. 하지만 정확히는 call by value로 참조 주소가 전달되기때문에, 종종 call by sharing이라고도 불립니다.
<br>참고 : https://velog.io/@ahnick/Java-Call-by-Value-Call-by-Reference
</details>

<details markdown = "1">
<summary> 클래스 변수, 지역 변수, 인스턴스 변수의 차이에 대해 설명해주세요 </summary>
클래스 변수는 static 키워드를 사용해 선언되며, 클래스 레벨에서 정의가 됩니다. 이는 해당 클래스의 모든 객체가 공유하며, JVM의해 클래스가 로드될때 메모리에 할당됩니다.<br>
인스턴스 변수는 객체마다 개별적으로 존재하며, 객체가 생성될 때 메모리에 할당됩니다.<br>
지역변수는 메서드나 블록 내에서 선언되며, 해당 영역 내에서만 사용할 수 있습니다. 이는 스택 영역에 할당되며, 영역을 벗어나면 메모리에서 해제됩니다.
<br><br>
참고 : 클래스 변수, 인스턴스 변수 둘다 멤버 변수<br>
참고 : 인스턴스 변수는 객체가 생성될 때마다 힙(heap) 영역에 매번 새로 생성되며, 각 객체마다 독립적인 변수를 가지게 됩니다. 지역 변수는 메서드가 호출될 때마다 스택(stack) 영역에 새로 생성되고 메서드 호출이 종료되면 소멸합니다. 반면에 클래스 변수는 static Area에 한 번만 생성되어 해당 클래스의 모든 객체가 공유합니다.
멤버변수는 지역 변수와 다르게 각 타입의 기본 값으로 자동 초기화<br> 
참고 : 자바를 실행했다고 바로 메모리에 올라가는 것이 아님, 클래스 로드 시점은 다음과같다<br>
1. 클래스 인스턴스를 생성하려할때
2. 클래스의 정적 멤버에 접근하려할떄!(중요!!)
3. 클래스를 직접 로드하는 경우 Class.forName()
</details>

<details markdown = "1">
<summary>상속이란 무엇인가요?</summary>
상위 클래스를 상속 받게 되면 하위 클래스, 즉 상속받은 클래스는 상위 클래스의 변수나 메서드를 사용할 수 있게 됩니다.<br>
이게 가능한 이유는 하위 클래스 생성 시 상위 클래스의 생성자가 먼저 호출되고 하위 클래스의 생성자가 호출되로고 프로그램 내부에 이미 설정되어 있기 때문입니다. <br>
즉 하위 클래스 생성자에서 super()를 자동으로 호출하게 됩니다.<br>
이러한 상속에는 예약어 extends가 사용됩니다.
</details>

<details markdown = "1">
<summary>오버로딩과 오버라이딩에 대해 설명해주세요</summary>
오버로딩은 같은 이름의 메서드를 여러 개 정의하되, 매개변수의 개수나 타입이 다르게 하는 것입니다.
이를 통해 다양한 매개변수를 받을 수 있는 메서드를 구현할 수 있습니다.
반면에 오버라이딩은 상속 관계에서 자식 클래스가 부모 클래스가 정의한 메서드를 재정의하는 것입니다. 
메서드의 시그니처는 동일하게 유지되지만, 구현 내용이 변경되어 자식 클래스의 요구에 맞게 동작할 수 있습니다. 
이를 통해 다형성을 구현할 수 있습니다.

참고 : 다형성이란 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있도록 하는 것!
</details>

<details markdown = "1">
<summary>접근 제어자에 대해 설명해주세요</summary>
접근 제어자란 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 합니다.<br>
이러한 접근제어자에는 private, default, protected, public이 있습니다.<br>
private의 경우에는 같은 클래스내에서만 접근이 가능하고, default의 경우에는 같은 패키지 내에서만 접근이 가능합니다.<br>
protected의 경우에는 같은 패키지내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하고 public의 경우에는 접근 제한이 전혀 없습니다.<br>
</details>

<details markdown = "1">
<summary>클래스란 무엇인가요?</summary>
클래스는 객체의 속성과 기능을 코드로 구현한것입니다. 자바에서의 모든 코드는 클래스 안에서 정의되어있습니다.
</details>

<details markdown = "1">
<summary>static 예약어에 대해 설명해주세요</summary>
자바에서 static은 클래스 레벨에서 공유되는 멤버를 선언하는데 사용되는 예약어입니다.<br>
이 키워드를 사용해 변수, 메서드, 내부 클래스를 정의할 수 있습니다.<br>
static 변수는 클래스의 모든 인스턴스가 공유하는 변수로 클래스 로드 시 메모리에 한번 할당되고, 인스턴스 생성과 무관하게 사용 가능합니다.<br>
static 메서드는 클레스 레벨에서 동작하는 메서드로, 인스턴스 생성없이 호출 할 수 있습니다.<br>
static 내부 클래스는 클래스 내부에 정의된 정적 클래스로, 외부 클래스와 독립적으로 동작합니다.<br>
따라서 외부 클래스의 인스턴스 생성과 상관없이 사용할 수 있습니다.<br>
참고 : 보통 유틸리티 메서드를 포함하는 클래스에 사용<br>
</details>

<details markdown = "1">
<summary>final 예약어에 대해 설명해주세요</summary>
final 예약어는 값이 변하지 않는 상수를 선언할때나 메서드의 재정의 및 클래스 확장을 방지하기 위해 주로 사용됩니다.<br>
변수에 final을 붙이면 해당 변수는 변경 될수 없는 상수가 되고, 메서드에 final을 붙으면 이는 재정의가 불가능해집니다.<br>
또한 클래스에 final을 붙으면 다른 클래스에서 이를 상속할 수 없습니다.
</details>

<details markdown = "1">
<summary>추상 클래스에 대해 설명해주세요</summary>
일반적으로 추상 메서드를 가지고 있는 클래스를 추상 클래스라고 합니다. 추상 메서드는 구현부가 없는 메서드를 뜻합니다.<br>
이러한 추상 클래스를 상속받은 클래스는 추상 메서드를 모두 구현하던가, 본인도 추상 클래스로 만들어야 오류가 발생하지 않으며 예약어 abstract를 사용합니다.<br>
참고 : extends 사용<br>
참고 : abstract 안 붙여도 구현부가 없는 메서드는 추상 메서드로 분류함<br>
참고 : 추상 클래스는 일반 메서드도 가질 수 있음<br>
참고 : 새로운 클래스를 작성할때 일종의 설계도 역할을 해줌, 공통 기능을 상속해 주기 위한 용도<br>
</details>

<details markdown = "1">
<summary>인터페이스에 대해 설명해주세요</summary>
인터페이스는 자바에서 클래스들이 공통적으로 가져야 할 메서드를 명세하는 추상화된 개념입니다.<br>
이러한 인터페이스는 추상 메서드와 상수만을 가질 수 있으며, 인스턴스화 할 수 없습니다.<br>
사용 목적에 대해 간단히 말씀드리자면 우선 클래스들이 가져야 할 메서드의 시그니처를 정의함으로서, 클래스가 구현해야 하는 행동을 지정할 수 있습니다.<br>
또한 인터페이스를 구현하는 여러 클래스는 동일한 인터페이스 메서드를 사용하여 다양한 구현을 제공할 수 있습니다.<br>
이를 통해 구현체에 의존하지 않고 인터페이스에 의존하게 되어 유연성과 확장성이 향상됩니다.<br>

참고 : 추상 클래스는 추상 메서드를 가진 클래스이고, 인터페이스는 추상 메서드로만 이루어진 클래스<br>
참고 : 인터페이스, 추상클래스 둘의 메서드는 상속되어야 하기 때문에 final 키워드 붙지 않음
</details>

<details markdown = "1">
<summary>추상 클래스와 인터페이스의 차이에 대해 설명해주세요</summary>
추상 클래스는 상속받은 클래스의 기능을 이용하고 확장하는 것이고, 인터페이스는 하위클래스에게 일종의 설계도를 제공하는 것입니다.<br>
추상 클래스 상속과 같이 extends 관계를 가진 경우에는 자식이 부모의 필드나 메서드를 참조할 수 있기 때문에, 자식이 부모의 기능을 확장한 구조로 이루어집니다.<br>
따라서 부모-자식 관계 뿐 아니라, 같은 부모에서 확장된 자식 클래스들끼리도 어느정도 역할에 공통점이 존재해야 합니다.<br>
반면 인터페이스의 구현체의 경우, 자식들간에 전혀 아무런 관계가 없더라도 인터페이스와 관계를 맺을 수 있습니다.<br>
요약하자면 밀접하게 관련된 클래스들끼리 코드를 공유해야 할때는 추상클래스, 서로 관계 없는 클래스들끼리 관계를 맺어주고 특정 데이터 타입의 메서드를 사용하려고 할때, 해당 동작을 누가 구현해는지 중요하지 않거나<br>
다중 상속이 필요한 경우 인터페이스를 사용하는 것이 좋습니다.<br>
</details>

<details markdown = "1">
<summary>오류와 예외의 차이에 대해 설명해주세요</summary>
오류(Error)는 시스템 레벨에서 발생하고 예외(Exception)은 개발자가 구현한 로직에서 발생합니다.
</details>

<details markdown = "1">
<summary>Checked예외와 UnChecked 예외의 차이에 대해 설명해주세요</summary>
둘의 가장 명확한 구분 기준은 꼭 처리를 해야 하느냐 입니다.<br>
Checked Exception이 발생할 가능성이 있는 메서드라면 반드시 오류 처리(try/catch, throw)를 해주어야 합니다.<br>
반면 Unchecked Exception은 명시적인 예외처리를 하지 않아도 됩니다.<br>
또한 예외를 확인하는 시점에서도 구분할 수 있습니다.<br>
일반적으로 컴파일 단계에서 명확하게 Exception 체크가 가능한 것을 Checked Exception이라 하며, 실행 과정 중 발견되는 Exception을 Unchecked Exception이라고 합니다.<br>
그리고 트랜잭션 roll-back 여부에도 차이가 있습니다.
기본적으로 Checked Exception은 예외가 발생하면 트랜잭션을 roll-back하지 않고 예외를 던져주는 반면, Unchecked Exception은 예외 발생 시 트랜잭션을 roll-back한다는 점에서 차이가 있습니다.</br>
- 참고 : 롤백이란 트랜잭션 내에서 발생한 모든 변경 작업을 취소하고 이전 상태로 돌리는 과정(데이터 일관성 유지)
- 대표적인 Checked : Exception , UnChecked : RuntimeException
</details>

<details markdown = "1">
<summary>문자열을 리터럴(string = "abcd")로 할당하는 것과 객체(string = new String("abcd"))로 할당하는 방식의 차이가 무엇인가요?</summary>
문자열을 리터럴과 객체로 할당하는 방식의 차이는 메모리 할당 방식과 성능에 있습니다.<br>
자바 소스 코드에 포함된 모든 문자열 리터럴은 컴파일시에 클래스 파일에 저장됩니다. <br>
이후 클래스 파일이 클래스 로더에 의해 메모리에 올라갈때, 클래스 파일의 리터럴들이 JVM 내에 있는 String constant pool에 올라가게 됩니다.<br>
이때 같은 문자열 리터럴이 여러번 사용될 경우, 중복을 방지하기 위해 하나의 인스턴스를 공유하게 됩니다. <br>
이러한 리터럴 방식은 중복을 최소화 하고 메모리를 효율적으로 사용할 수 있습니다.<br>
반면 new 키워드로 문자열 객체를 생성할 시 힙 영역에 새로운 객체가 생성됩니다.<br>
이 경우에는 같은 문자열이라도 매번 새로운 객체를 생성하게 되어 메모리 사용에 비효율적 입니다<br>

참고 - 문자열 풀은 메소드 영역에 위치
</details>

<details markdown = "1">
<summary>자바에서는 왜 String을 불변 객체로 만들었을까요?</summary>
만약 불변성이 아니라면, 문자열을 변경하는 경우 새로운 문자열 객체를 생성해야 하기에 메모리 사용량이 늘어날것입니다.<br>
하지만 불변성을 가진 문자열은 한 번 생성되면 변경되지 않으므로, 문자열 풀에서 중복을 피해 효율적으로 메모리를 사용할 수 있습니다.<br>
또한 다른 코드에 의해 예기치 않게 변경되는 것을 막을 수 있고, 여러 쓰레드에서 동시에 접근하더라도 별도의 동기화 없이 스레드 안전성을 보장할 수 있습니다.<br>

참고 
MutableString str = new MutableString("Hello, World!");<br>
str.append("!")<br>
이 경우 동일한 문자열을 가리키는 다른 변수가 있을 때 원치 않는 변경이 일어날 수 있기에 변경할때마다 새로운 문자열 객체를 생성해야함<br>
</details>