# 자바

<details markdown = "1">
<summary>기본형과 참조형이 무엇인지와 그에 대한 차이를 설명해주세요.</summary>

자바에서는 총 8가지의 기본형 타입(byte, short, int, long, float, double, char, boolean)을 미리 정의하고 제공해줍니다.<br>
기본형 변수는 메모리의 스택 영역에 할당되며, 값이 저장될때 해당 메모리 위치에 직접 저장됩니다.<br>
참조형 타입에는 클래스, 인터페이스, 배열 등이 있습니다. 참조형 변수는 메모리의 스택 영역에 할당되며, 객체는 힙 영역에 할당됩니다.<br>
이때 참조형 변수는 힙 영역에 저장된 객체의 주소를 가리키고 있는 것이 특징입니다.
</details>

<details markdown = "1">
<summary> 자바에서 '=='연산자와 'equals()' 메서드의 차이에 대해 설명해주세요 </summary>

두 변수가 같은 객체(같은 메모리 공간)를 가리키는지 확인하려면 ==를 사용하고, 객체의 내용 자체가 동일한지 확인하려면 equals()를 사용해야 합니다. <br>
기본형 변수의 경우 ==를 사용하면 됩니다. 하지만 참조형 변수의 경우, 특히 문자열이나 사용자 정의 클래스와 같은 객체를 비교할 때는 equals() 메서드를 사용하는 것이 좋습니다.<br>
참고: equals는 override 할 수 있기 때문에 사용자가 원하는 논리적인 통일성을 비교할 수 있다.<br>
참고 : equals는 주소 값을 자체를 비교하는 것은 아니지만 주소값을 통해서 비교를 함
</details>

<details markdown = "1">
<summary> call by reference 와 call by value의 차이에 대해 설명해주세요.</summary>

call by value와 call by reference는 함수 호출 시 인자 전달 방식의 차이를 나타냅니다.<br>
call by value는 함수에 인자를 전달할때 값을 넘겨받은 메소드에서
값을 복사하여 새로운 지역 변수에 저장하는 방식입니다. 이 경우, 함수 내에서 인자 값이 변경되더라도 원래 변수에는 영향을 미치지 않습니다.<br>
반면 call by reference는 함수에 인자를 전달할때 변수의 주소를 전달하는 방식입니다. 이 경우 함수 내에서 인자 값이 변경되면 원래 변수의 값도 함께 변경됩니다.<br>
자바에서는 기본형 변수를 함수의 인자로 전달할때 call by value 방식을 사용하고, 참조형 변수를 전달할때는 call by reference의 개념과 유사한 방식을 사용합니다. 하지만 정확히는 call by value로 참조 주소가 전달되기때문에, 종종 call by sharing이라고도 불립니다.
<br>참고 : https://velog.io/@ahnick/Java-Call-by-Value-Call-by-Reference
</details>

<details markdown = "1">
<summary> 클래스 변수, 지역 변수, 인스턴스 변수의 차이에 대해 설명해주세요 </summary>
클래스 변수는 static 키워드를 사용해 선언되며, 클래스 레벨에서 정의가 됩니다. 이는 해당 클래스의 모든 객체가 공유하며, JVM의해 클래스가 로드될때 메모리에 할당됩니다.<br>
인스턴스 변수는 객체마다 개별적으로 존재하며, 객체가 생성될 때 메모리에 할당됩니다.<br>
지역변수는 메서드나 블록 내에서 선언되며, 해당 영역 내에서만 사용할 수 있습니다. 이는 스택 영역에 할당되며, 영역을 벗어나면 메모리에서 해제됩니다.
<br><br>
참고 : 클래스 변수, 인스턴스 변수 둘다 멤버 변수<br>
참고 : 인스턴스 변수는 객체가 생성될 때마다 힙(heap) 영역에 매번 새로 생성되며, 각 객체마다 독립적인 변수를 가지게 됩니다. 지역 변수는 메서드가 호출될 때마다 스택(stack) 영역에 새로 생성되고 메서드 호출이 종료되면 소멸합니다. 반면에 클래스 변수는 static Area에 한 번만 생성되어 해당 클래스의 모든 객체가 공유합니다.
멤버변수는 지역 변수와 다르게 각 타입의 기본 값으로 자동 초기화<br> 
참고 : 자바를 실행했다고 바로 메모리에 올라가는 것이 아님, 클래스 로드 시점은 다음과같다<br>
1. 클래스 인스턴스를 생성하려할때
2. 클래스의 정적 멤버에 접근하려할떄!(중요!!)
3. 클래스를 직접 로드하는 경우 Class.forName()
</details>

<details markdown = "1">
<summary>상속이란 무엇인가요?</summary>
상위 클래스를 상속 받게 되면 하위 클래스, 즉 상속받은 클래스는 상위 클래스의 변수나 메서드를 사용할 수 있게 됩니다.<br>
이게 가능한 이유는 하위 클래스 생성 시 상위 클래스의 생성자가 먼저 호출되고 하위 클래스의 생성자가 호출되로고 프로그램 내부에 이미 설정되어 있기 때문입니다. <br>
즉 하위 클래스 생성자에서 super()를 자동으로 호출하게 됩니다.<br>
이러한 상속에는 예약어 extends가 사용됩니다.
</details>

<details markdown = "1">
<summary>오버로딩과 오버라이딩에 대해 설명해주세요</summary>
오버로딩은 같은 이름의 메서드를 여러 개 정의하되, 매개변수의 개수나 타입이 다르게 하는 것입니다.
이를 통해 다양한 매개변수를 받을 수 있는 메서드를 구현할 수 있습니다.
반면에 오버라이딩은 상속 관계에서 자식 클래스가 부모 클래스가 정의한 메서드를 재정의하는 것입니다. 
메서드의 시그니처는 동일하게 유지되지만, 구현 내용이 변경되어 자식 클래스의 요구에 맞게 동작할 수 있습니다. 
이를 통해 다형성을 구현할 수 있습니다.

참고 : 다형성이란 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있도록 하는 것!
</details>

<details markdown = "1">
<summary>접근 제어자에 대해 설명해주세요</summary>
접근 제어자란 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 합니다.<br>
이러한 접근제어자에는 private, default, protected, public이 있습니다.<br>
private의 경우에는 같은 클래스내에서만 접근이 가능하고, default의 경우에는 같은 패키지 내에서만 접근이 가능합니다.<br>
protected의 경우에는 같은 패키지내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하고 public의 경우에는 접근 제한이 전혀 없습니다.<br>
</details>

<details markdown = "1">
<summary>클래스란 무엇인가요?</summary>
클래스는 객체의 속성과 기능을 코드로 구현한것입니다. 자바에서의 모든 코드는 클래스 안에서 정의되어있습니다.
</details>

<details markdown = "1">
<summary>static 예약어에 대해 설명해주세요</summary>
자바에서 static은 클래스 레벨에서 공유되는 멤버를 선언하는데 사용되는 예약어입니다.<br>
이 키워드를 사용해 변수, 메서드, 내부 클래스를 정의할 수 있습니다.<br>
static 변수는 클래스의 모든 인스턴스가 공유하는 변수로 클래스 로드 시 메모리에 한번 할당되고, 인스턴스 생성과 무관하게 사용 가능합니다.<br>
static 메서드는 클레스 레벨에서 동작하는 메서드로, 인스턴스 생성없이 호출 할 수 있습니다.<br>
static 내부 클래스는 클래스 내부에 정의된 정적 클래스로, 외부 클래스와 독립적으로 동작합니다.<br>
따라서 외부 클래스의 인스턴스 생성과 상관없이 사용할 수 있습니다.<br>
참고 : 보통 유틸리티 메서드를 포함하는 클래스에 사용<br>
</details>

<details markdown = "1">
<summary>final 예약어에 대해 설명해주세요</summary>
final 예약어는 값이 변하지 않는 상수를 선언할때나 메서드의 재정의 및 클래스 확장을 방지하기 위해 주로 사용됩니다.<br>
변수에 final을 붙이면 해당 변수는 변경 될수 없는 상수가 되고, 메서드에 final을 붙으면 이는 재정의가 불가능해집니다.<br>
또한 클래스에 final을 붙으면 다른 클래스에서 이를 상속할 수 없습니다.
</details>

<details markdown = "1">
<summary>추상 클래스에 대해 설명해주세요</summary>
일반적으로 추상 메서드를 가지고 있는 클래스를 추상 클래스라고 합니다. 추상 메서드는 구현부가 없는 메서드를 뜻합니다.<br>
이러한 추상 클래스를 상속받은 클래스는 추상 메서드를 모두 구현하던가, 본인도 추상 클래스로 만들어야 오류가 발생하지 않으며 예약어 abstract를 사용합니다.<br>
참고 : extends 사용<br>
참고 : abstract 안 붙여도 구현부가 없는 메서드는 추상 메서드로 분류함<br>
참고 : 추상 클래스는 일반 메서드도 가질 수 있음<br>
참고 : 새로운 클래스를 작성할때 일종의 설계도 역할을 해줌, 공통 기능을 상속해 주기 위한 용도<br>
</details>

<details markdown = "1">
<summary>인터페이스에 대해 설명해주세요</summary>
인터페이스는 자바에서 클래스들이 공통적으로 가져야 할 메서드를 명세하는 추상화된 개념입니다.<br>
이러한 인터페이스는 추상 메서드와 상수만을 가질 수 있으며, 인스턴스화 할 수 없습니다.<br>
사용 목적에 대해 간단히 말씀드리자면 우선 클래스들이 가져야 할 메서드의 시그니처를 정의함으로서, 클래스가 구현해야 하는 행동을 지정할 수 있습니다.<br>
또한 인터페이스를 구현하는 여러 클래스는 동일한 인터페이스 메서드를 사용하여 다양한 구현을 제공할 수 있습니다.<br>
이를 통해 구현체에 의존하지 않고 인터페이스에 의존하게 되어 유연성과 확장성이 향상됩니다.<br>

참고 : 추상 클래스는 추상 메서드를 가진 클래스이고, 인터페이스는 추상 메서드로만 이루어진 클래스<br>
참고 : 인터페이스, 추상클래스 둘의 메서드는 상속되어야 하기 때문에 final 키워드 붙지 않음
</details>

<details markdown = "1">
<summary>추상 클래스와 인터페이스의 차이에 대해 설명해주세요</summary>
추상 클래스는 상속받은 클래스의 기능을 이용하고 확장하는 것이고, 인터페이스는 하위클래스에게 일종의 설계도를 제공하는 것입니다.<br>
추상 클래스 상속과 같이 extends 관계를 가진 경우에는 자식이 부모의 필드나 메서드를 참조할 수 있기 때문에, 자식이 부모의 기능을 확장한 구조로 이루어집니다.<br>
따라서 부모-자식 관계 뿐 아니라, 같은 부모에서 확장된 자식 클래스들끼리도 어느정도 역할에 공통점이 존재해야 합니다.<br>
반면 인터페이스의 구현체의 경우, 자식들간에 전혀 아무런 관계가 없더라도 인터페이스와 관계를 맺을 수 있습니다.<br>
요약하자면 밀접하게 관련된 클래스들끼리 코드를 공유해야 할때는 추상클래스, 서로 관계 없는 클래스들끼리 관계를 맺어주고 특정 데이터 타입의 메서드를 사용하려고 할때, 해당 동작을 누가 구현해는지 중요하지 않거나<br>
다중 상속이 필요한 경우 인터페이스를 사용하는 것이 좋습니다.<br>
</details>

<details markdown = "1">
<summary>오류와 예외의 차이에 대해 설명해주세요</summary>
오류(Error)는 시스템 레벨에서 발생하고 예외(Exception)은 개발자가 구현한 로직에서 발생합니다.
</details>

<details markdown = "1">
<summary>Checked예외와 UnChecked 예외의 차이에 대해 설명해주세요</summary>
둘의 가장 명확한 구분 기준은 꼭 처리를 해야 하느냐 입니다.<br>
Checked Exception이 발생할 가능성이 있는 메서드라면 반드시 오류 처리(try/catch, throw)를 해주어야 합니다.<br>
반면 Unchecked Exception은 명시적인 예외처리를 하지 않아도 됩니다.<br>
또한 예외를 확인하는 시점에서도 구분할 수 있습니다.<br>
일반적으로 컴파일 단계에서 명확하게 Exception 체크가 가능한 것을 Checked Exception이라 하며, 실행 과정 중 발견되는 Exception을 Unchecked Exception이라고 합니다.<br>
그리고 트랜잭션 roll-back 여부에도 차이가 있습니다.
기본적으로 Checked Exception은 예외가 발생하면 트랜잭션을 roll-back하지 않고 예외를 던져주는 반면, Unchecked Exception은 예외 발생 시 트랜잭션을 roll-back한다는 점에서 차이가 있습니다.</br>
- 참고 : 롤백이란 트랜잭션 내에서 발생한 모든 변경 작업을 취소하고 이전 상태로 돌리는 과정(데이터 일관성 유지)
- 대표적인 Checked : Exception , UnChecked : RuntimeException
</details>

<details markdown = "1">
<summary>문자열을 리터럴(string = "abcd")로 할당하는 것과 객체(string = new String("abcd"))로 할당하는 방식의 차이가 무엇인가요?</summary>
문자열을 리터럴과 객체로 할당하는 방식의 차이는 메모리 할당 방식과 성능에 있습니다.<br>
자바 소스 코드에 포함된 모든 문자열 리터럴은 컴파일시에 클래스 파일에 저장됩니다. <br>
이후 클래스 파일이 클래스 로더에 의해 메모리에 올라갈때, 클래스 파일의 리터럴들이 JVM 내에 있는 String constant pool에 올라가게 됩니다.<br>
이때 같은 문자열 리터럴이 여러번 사용될 경우, 중복을 방지하기 위해 하나의 인스턴스를 공유하게 됩니다. <br>
이러한 리터럴 방식은 중복을 최소화 하고 메모리를 효율적으로 사용할 수 있습니다.<br>
반면 new 키워드로 문자열 객체를 생성할 시 힙 영역에 새로운 객체가 생성됩니다.<br>
이 경우에는 같은 문자열이라도 매번 새로운 객체를 생성하게 되어 메모리 사용에 비효율적 입니다<br>

참고 - String Pool이 메소드 영역에 위치한다는 표현은 JVM 구조를 간략화한 표현입니다. 사실, 정확하게는 String Pool은 Heap 영역에 위치한 특별한 영역입니다.<br>
</details>

<details markdown = "1">
<summary>자바에서는 왜 String을 불변 객체로 만들었을까요?</summary>
만약 문자열이 불변성을 가지지 않는다면, 문자열이 수정될 때마다 새로운 문자열 객체가 생성되어야 하므로 메모리 부담이 커집니다.<br>
그러나 불변성을 가진 문자열은 한 번 생성되면 그 상태가 변하지 않습니다. <br>
따라서 동일한 문자열을 여러 번 사용해도 String Pool에서는 단 한 번만 저장되므로, 메모리 사용에 있어서 효율적이며, 중복 생성을 방지해 메모리 공간 절약 및 성능을 향상시킬수있습니다.<br>
또한 다른 코드에 의해 예기치 않게 변경되는 것을 막을 수 있고, 여러 쓰레드에서 동시에 접근하더라도 별도의 동기화 없이 스레드 안전성을 보장할 수 있습니다.<br>

참고 
MutableString str = new MutableString("Hello, World!");<br>
str.append("!")<br>
이 경우 동일한 문자열을 가리키는 다른 변수가 있을 때 원치 않는 변경이 일어날 수 있기에 변경할때마다 새로운 문자열 객체를 생성해야함<br>
String이 불변인 이유 -> 내부에 char[] value 배열이 final임! <br>
</details>

<details markdown = "1">
<summary>StringBuffer, StringBuilder 차이는 무엇이죠?</summary>
StringBuilder와 StringBuffer는 모두 문자열을 변경하거나 추가하는 연산을 제공하는 가변성 클래스입니다<br>
이 둘을 가르는 차이점은 동기화에 있습니다<br>
StringBuffer는 각 메서드에 대한 동기화를 지원하므로 멀티쓰레드 환경에서 안전합니다.<br>
즉 여러 스레드가 동시에 객체를 변경할 수 없으므로, 멀티스레드 환경에서 사용하면 좋습니다<br>
반면 StringBuilder는 동기화를 지원하지 않습니다. 하지만 단일 스레드 환경일 시 더 빠른 성능을 보입니다.<br><br>

참고 - 문자열 끼리 더하기 할시, 실제로는 새로운 객체를 생성한다기 보단(반은 맞고 반은 틀림), 컴파일 전 내부적으로 STringBuilder 클래스를 만들어서 사용<br>
즉, "hello" + "world" 문자열 연산이 있다면 이는 new StringBuilder("hello").append("world").toString() 과 같다는 말이다.<br>
참고 - 소켓과 같은 비동기 상황에서는 Buffer 사용하기<br>
참고 - StringBuilder와 StringBuffer는 문자열을 추가하거나 변경할 때, 새로운 객체를 생성하는 것이 아니라 기존 객체를 직접 변경합니다.<br>
참고 - String은 불변이기에 멀티쓰레드 상황 생각할 필요 X<br>

꼬리질문 - 왜 동기화가 걸려있으면 느린걸까요?
동기화란 여러 스레드가 동시에 특정 코드블록이나 메서드에 접근하는 것을 방지하여, 데이터 불일치 문제를 해결하는 기법입니다.<br>
예를들어 두개의 스레드가 동시에 StringBuffer 객체를 수정하려고 시도하면, 동기화된 메서드는 한번의 하나의 스레드의 작업만을 허용합니다.<br>
이로 인해 다른 스레드는 첫번째 스레드가 작업을 완료할때까지 기다려야하며, 이 동안 성능이 저하될수 있습니다.<br>
이렇게 스레드가 다른 스레드의 작업을 완료하기를 기다리는 것을 블로킹이라고 합니다. 이러한 블로킹은 많은 시스템 리소스를 소비하고,<br>
이 동안 CPU는 유휴상태가 될 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>왜 StringBuilder가 단일 스레드 환경에서 더 빠른 성능을 보이죠? </summary>
StringBuilder가 단일 스레드 환경에서 더 빠른 성능을 보이는 이유는 '동기화 오버헤드' 때문입니다.<br>

동기화는 멀티스레드 환경에서 데이터의 일관성을 유지하기 위해 필요한 작업이지만, 그 과정에서 추가적인 시스템 리소스를 소모합니다. 이를 '동기화 오버헤드'라고 합니다.<br>

StringBuffer의 모든 주요 메소드는 동기화 되어 있습니다. 따라서 멀티스레드 환경에서는 안전하지만, 단일 스레드 환경에서는 필요 없는 동기화 비용이 발생하게 됩니다.<br>

반면에 StringBuilder는 동기화를 지원하지 않습니다. <br>
그래서 동기화에 따른 오버헤드 없이 작동하기 때문에, 단일 스레드 환경에서는 StringBuilder가 StringBuffer보다 빠른 성능을 보이게 됩니다."
</details>

<details markdown="1">
<summary>String, StringBuffer, StringBuilder 차이:star:  </summary>
A)<br>

<img src="https://user-images.githubusercontent.com/78812317/171040842-1b72da3f-0b74-4c14-b7f3-3ea84399c5c8.png">
<br>
String 객체는 한번 생성되면 할당 메모리 공간이 변하지 않습니다. 따라서 값이 변경되지 않습니다.<br>
장점-불변이기때문에 단순 조회연산에서 타 클래스보다 빠르고, 불변이기때문에 동기화를 신경쓸 필요가 없습니다.<br>
단점-문자열연산이 자주 일어나면 더이상 참조되지 않는 객체는 GC대상이 되며 이들이 쌓입니다.<br>
<br>
StringBuffer, StringBuilder는 mutable(가변)입니다. 문자열 연산 시 메모리 크기를 변경시켜 문자열이 변경됩니다.<br>
문자열 연산이 자주 있을 시 사용하는 것이 좋습니다.<br>
둘 사이의 차이는 동기화 여부에 있습니다. <br>
StringBuffer는 메서드마다 synchronized 예약어가 걸려있어 멀티스레드 환경에서 동기화를 지원합니다.<br>
StringBuilder는 동기화를 보장하지 않습니다. 그 대신 연산처리가 StringBuffer보다 빠릅니다.<br>
결론적으로 멀티스레드 환경에선 StringBuffer, 싱글스레드 환경에선 StringBuilder를 사용하는 것이 좋습니다.<br>
</details>

<details markdown = "1">
<summary>래퍼 클래스란 무엇이죠? </summary>
래퍼 클래스란 자바의 기본형 데이터 타입을 객체로 다루기 위한 클래스를 의미합니다.<br>
이러한 각각 기본 데이터 타입에 대응하는 래퍼 클래스가 있으며, 이를 통해 기본 데이터 타입도 객체처럼 다룰수 있습니다.<br>

참고 - int : Integer, char : Character, 나머지는 기본 타입의 앞글자만 대문자
</details>

<details markdown = "1">
<summary>래퍼 클래스를 사용하는 이유엔 어떤것들이 있을까요?</summary>
예를들어, 메서드의 매개변수로 객체가 필요한 경우 사용할 수 있을 것같습니다. 그리고 null값을 사용해야 할때 Wrapper클래스를 사용하면 null값을 표현할 수 있습니다.<br>
또한 자바의 제네릭은 기본 데이터 타입을 지원하지 않습니다. 따라서 기본 데이터 타입을 사용하려면 해당 Wrapper클래스를 사용해야 합니다.<br>
그리고 멀티스레드 환경에서 동기화 기능을 적용하기 위해 기본 타입의 값에 대한 Wrapper 클래스를 사용하게 됩니다.<br>

참고: 기본 데이터 타입은 객체가 아니라서 직접 동기화를 수행할 수 없다.(객체만 java의 동기화 메커니즘을 사용할수 있기에..)
참고 : 일반적으로 객체의 경우 외부에서 함부로 값을 변경할 수 없음...(바꿀려면 아마 set? : 캡술화 반영)
</details>

<details markdown = "1">
<summary>Boxing과 UnBoxing이 무엇이죠?</summary>
박싱은 기본 타입의 데이터를 래퍼 클래스의 인스턴스로 변환하는 것이고<br>
언박싱은 래퍼클래스의 인스턴스에 저장된 값을 기본 타입의 데이터로 변환하는 것입니다.<br>
</details>

<details markdown = "1">
<summary>AutoBoxing과 UnBoxing이 무엇인지와 사용시 주의해야할점에 대해 설명해주세요.</summary>
오토 박싱이란 기본 데이터 타입의 값을 래퍼 클래스의 객체로 변환하는 과정입니다.<br>
오토 언박싱은 래퍼 클래스의 객체가 그에 해당하는 기본데이터 타입의 값으로 변환되는 과정을 말합니다.<br>
주의해야할 점으로 우선 성능상의 이슈가 있습니다.<br>
AutoBoxing과 UnBoxing은 내부적으로 객체를 생성하거나, 참조를 변환해야 하는 과정을 거치므로 반복적인 연산이 필요한 경우 성능 저하를 일으킬 수 있습니다.<br>
또한 AutoBoxing을 통해 래퍼 클래스의 객체를 생성할때 null을 할당할 경우, 이후 UnBoxing 시 NPE가 발생할 수 있습니다.<br>
또한 == 로 값을 비교할때 값이 아닌 참조를 비교하게 되므로 이에 대해 주의해야 합니다.<br>
</details>

<details markdown = "1">
<summary>Enum이란 무엇이죠?</summary>
Enum이란 서로 연관된 상수들의 집합을 의미합니다.<br>
enum을 사용하면 enum이 가질 수 있는 값의 범위를 벗어나는 값을 사용할려 할 시 컴파일 시점에 에러로 잡아낼 수 있습니다.<br>
또한 enum의 각 상수는 해당 타입의 유일한 인스턴스를 나타내므로, 이를 통해 Singleton을 쉽게 구현할 수 있습니다.<br>
따라서 멀티쓰레드 상황에서 안전<br>
</details>

<details markdown = "1">
<summary>프레임워크와 라이브러리의 차이에 대해 설명해주세요.</summary>
프레임워크란 소프트웨어 개발을 위해 만들어진 구조나 도구의 집합을 의미합니다.<br>
개발자는 프레임워크의 규칙과 패턴에 따라 개발을 진행하며, 프레임워크가 제공하는 틀안에서 구현한 코드를 실행하고 확장할수 있습니다.<br>
라이브러리는 소프트웨어 개발에 자주 쓰일만한 코드를 미리 구현해놓고, 필요한 곳에서 호출하여 사용 가능하도록 만들어진 집합을 뜻합니다<br>
둘다 개발 생산성을 올리기 위한 도구라는 점에서 같지만, 이 둘은 흐름에 대한 제어의 권한이 어디있냐에 따라 차이가 있습니다.<br>
즉 프레임워크는 전체적인 흐름을 자체적으로 가지고 있으며 프로그래머가 그 안에 필요한 코드를 작성하는 반면(IOC)<br>
라이브러리는 사용자가 흐름에 대해 제어를 하며 필요한 상황에 가져다 쓰는 것입니다.<br>

참고 - 프레임워크에는 라이브러리들이 포함되어있음(라이브러리가 프레임워크 구성), 라이브러리 하나가 모듈과 유사한 개념<br>
참고 - 스프링에서 JPA는 라이브러리, 개발자는 필요한 경우 JPA를 선택하고, 기능을 사용하기 위해 해당 API 호출<br>
참고 - 스프링 프레임워크 자체는 JPA 라이브러리 사용하는 것 이상을 제공, 전체적인 구조와 흐름을 제어하기 위해 IOC 컨테이너와 DI 기능 제공<br>
</details>

<details markdown = "1">
<summary>Java Collection Framework란 무엇인가요?</summary>
컬렉션 프레임워크란 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스들의 집합을 의미합니다.<br>
이는 인터페이스와 다형성을 이용한 객체지향적 설계를 통해 표준화 되어 있어 사용법을 익히기 편리하며, <br>
배열과 다르게 동적으로 크기를 조정할 수 있습니다.(또한 다양한 메서드 지원)<br>
이러한 컬렉션 프레임워크는 Collection 인터페이스와 Map인터페이스로 나뉘며, Collection 인터페이스 하위에는 List,Queue,Set 인터페이스가 있습니다.<br>
참고 - 객체만 담을 수 있고, 이는 객체의 주소를 담는 것이기에 null도 저장 가능<br>
</details>

<details markdown = "1">
<summary>자료구조와 알고리즘에 대해 설명해주세요</summary>
자료구조는 데이터를 원하는 규칙 또는 목적에 맞게 저장하기 위한 구조이고<br>
알고리즘이란 자료구조에 쌓인 데이터를 활용해 어떠한 문제를 해결하기 위한 여러 동작들의 모임을 의미합니다.<br>
</details>

<details markdown = "1">
<summary>배열과 ArrayList의 차이에 대해 말씀해주세요</summary>
배열이란 동일한 데이터 타입의 값들을 연속된 메모리 공간에 저장하는 자료구조이며, 크기를 동적으로 변경할 수 없습니다.<br>
이러한 배열의 요소는 메모리에 연속적으로 저장되며, 각 요소는 고유한 인덱스를 가지므로 Random Access가 가능합니다.<br>
즉 논리적 저장순서와 물리적 저장순서가 일치하기에 인덱스를 통해 빠르게 요소에 접근할 수 있습니다.<br>
따라서 배열은 데이터 개수가 정해져있고, 접근이 빈번할 경우 사용하기 좋은 자료구조이나 중간에 요소가 삽입되거나 삭제되는 경우엔 적합하지 않은 자료구조입니다.<br>
또한 배열은 spacial locality(공간지역성)이 보장되어 요소 접근 시 Cache hit 가능성이 커 캐시의 효율성을 높일 수 있습니다.<br>
<br>
ArrayList는 배열과 마찬가지로 데이터 타입의 값들을 연속된 메모리 공간에 저장하며, 크기를 동적으로 변경할 수 있는 자료구조입니다.<br>
ArrayList는 내부의 Object[] 배열을 가지고 있어 각 요소가 인덱스를 가지고 있고, 이를 바탕으로 Random Access가 가능합니다.<br>
따라서 ArrayList는 데이터 개수가 정해져있지 않고, 접근이 빈번할 경우 사용하기 좋은 자료구조입니다.<br>
ArrayList 또한 마찬가지로 공간지역성이 보장되어 요소 접근 시 Cache hit 가능성이 커 캐시의 효율성을 높일 수 있습니다.<br>

<br>
참고 - Random Access란 데이터의 특정 위치에 직접 접근할 수 있는 능력을 의미합니다.<br>
배열에서 각 요소가 고유한 인덱스를 가지므로, 이를 통해 요소에 직접 접근이 가능<br>
메모리 상 시작 주소 + 인덱스 x 데이터 타입 크기(참조형 변수 크기는 4byte)를 통해 해당 인덱스의 값 빠르게 접근 가능<br>
참고 - 접근이나 수정(O(1)), 삽입 삭제는 다른 요소 옮겨야 하기에 O(n); value를 바탕으로 접근한다면 순차적으로 접근하는 것 생각<br>
참고 - 공간지역성이란, 관련된 데이터들이 연속적인 메모리 주소에 위치하면 그 데이터를 빠르게 읽고 쓸수 있다.<br>
참고 - 캐시히트란 필요한 데이터가 캐시에 있다면 캐시에서 빠르게 데이터를 가져오는 것을 의미한다<br>
참고 - 캐시 히트 가능성이 높다는 캐시에서 이 데이터를 찾을 확률이 높다<br>
ArrayList에서 삽입 연산시 내부 배열의 크기의 여유가 있고, 맨끝에 추가하기만 하는 경우엔 O(1)의 시간복잡도 가짐<br>
내부가 꽉찬 경우엔 끝에 추가하더라도, 배열의 크기를 늘리고 기존 배열의 element 값들을 복사해야 하기에 O(N), 중간의 경우는 당연히 O(N)<br>
삭제의 경우에도 삭제 뒤에 애들을 앞으로 땡겨야 하기에 O(n),근데 만약 마지막 값을 지운다면 O(1)일듯
<br><br><br>
꼬리질문 - 캐시 효율성에 대해 좀더 설명해주시겠어요?<br>
컴퓨터의 CPU는 계산을 수행하기 위해 데이터가 필요한데 이 데이터들은 보통 메모리에 저장되어 있습니다.<br>
이러한 CPU는 필요한 데이터를 RAM에서 읽어 수 있지만, 여기서 직접 데이터를 읽는 것은 상대적으로 느립니다.<br>
이를 위해 훨씬 빠른 속도를 가진 메모리인 캐시를 사용하며, 필요한 데이터가 캐시에 있다면 캐시에서 빠르게 데이터를 가져올수 있는데 이를 캐시히트가 발생되었다고 합니다.<br>
하지만 캐시의 크기는 매우 작기 때문에, 모든 데이터를 저장할 수는 없습니다. 따라서 CPU는 어떤 데이터를 캐시에 저장할지 결정해야 하는데 여기서 중요한 원칙이  <br>
공간지역성입니다.<br>
이는 메모리에 인접한 위치에 있는 데이터는 함께 사용될 가능성이 높다는 원리인데, 배열의 경우 모든 요소가 메모리 상 연속적으로 위치해있습니다.<br>
따라서 한번에 여러 요소를 캐시에 저장할 수 있고, 이후 배열에 접근할때 빠른 속도를 얻을 수 있습니다.<br>
요약하자면 배열의 요소들은 메모리상에 인접해 있기때문에, 한번에 여러 요소를 캐시에 저장할 수 있고, 그래서 CPU가 배열의 데이터에 빠르게 접근할 수 있습니다.<br>
<br>
참고 - 컴퓨터에서 데이터를 읽을때, 주소가 연속적인 메모리 위치에 있는 데이터를 읽는 것이 흩어진것 보다 효과적<br>
왜냐하면 컴퓨터는 메모리에서 블록 단위로 데이터를 읽음. 따라서 배열과 같이 데이터가 연속적인 메모리 위치에 있으면, 컴퓨터는 한번에 여러데이터 읽을 수 있따.<br>
이것이 한번에 여러 요소를 캐시에 저장할 수 있다는 의미.<br>
데이터가 메모리의 여러 위치에 있으면, 컴퓨터는 여러 블록을 읽어야 함(접근하는데 더 많은 시간이 듬)<br>
연관 데이터를 가능한 가까이 두는것이 캐시를 효율적으로 사용하고 성능을 높이는데 사용<br>
캐시 라인을 기반으로 읽어옴 예를들어 arr[0]이 캐시에 로드되면,arr[1],arr[2]등 같은 캐시라인에 있는 배열 요소도 같이 캐시에 로드됨<br>
즉 cpu가 램에서 데이xj를 가져올때 캐시 라인 단위로 가져옴(일반적으로 64바이트)<br>
따라서 cpu가 arr[0]의 값을 가져올때 캐시는 arr[0]을 포함하는 메모리 블록을 가져오며 여기엔 arr[0]제외 인접 데이터들도 포함됨<br>
따라서 arr[1],arr[2]는 캐시에 저장되고 나중에 접근할때는 RAM에 접근할 필요 X<br>

</details>
<details markdown = "1">
<summary>LinkedList에 대해 아시는 대로 설명해주세요.</summary>
LinkedList란 각 노드가 데이터와 포인터를 가지고 연결되어 있는 방식으로 데이터를 저장하는 자료구조입니다.<br>
이러한 링크드 리스트의 종류로는 단방향, 양방향, 원형 링크드리스트들이 존재합니다.<br>
LinkedList의 각 요소는 메모리상에 불연속적으로 배치되어 있습니다.<br>
따라서 특정 인덱스 요소에 접근하려면 ArrayList와 다르게 순차적으로 하므로 접근에 최적화된 자료구조는 아닙니다<br>
하지만 삽입 삭제가 빈번하게 일어나는 경우에는 유용한 자료구조이며, CPU 스케쥴링이나 메모리 관리 등에서 사용되는<br>
큐나 스택등의 자료구조를 구현하는데 사용될 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>ArrayList와 LinkedList의 차이에 대해 설명해주세요.</summary>
"ArrayList와 LinkedList는 자바에서 제공하는 주요 자료구조로서 각각이 독특한 특성을 가지고 있습니다.<br>
ArrayList는 동적 배열의 형태를 가지고 있어, 데이터가 메모리 상에서 연속적으로 배치됩니다.<br>
이로 인해 인덱스를 통해 빠르게 요소에 접근하는 것이 가능합니다. 이를 'random access'라고 합니다.<br>
그러나 이런 특성 때문에 중간에 새로운 요소를 삽입하거나 기존 요소를 삭제할 때는 배열의 요소들을 이동시키는 추가적인 작업이 필요합니다<br>
.이는 비효율적일 수 있습니다. 또한, 배열이 꽉 차면 크기를 늘려야 하며 이 과정에서도 시간이 소요됩니다. 하지만 ArrayList의 공간 지역성이 보장되므로, 캐시 히트 가능성이 높아져서 캐시의 효율성이 좋습니다.<br>

반면, LinkedList는 연결 리스트의 형태를 가지며, 각 요소가 메모리 상에서 불연속적으로 배치됩니다.<br>
이로 인해 인덱스를 통한 빠른 접근이 어렵습니다. 대신, LinkedList는 노드의 연결 정보만 변경함으로써 요소의 삽입과 삭제를 매우 효율적으로 수행할 수 있습니다.<br>
특히, 리스트의 시작 부분(head)나 끝 부분(tail)에서의 삽입 및 삭제는 매우 빠릅니다.<br> 
그러나 LinkedList는 공간 지역성이 보장되지 않아 캐시 히트 가능성이 낮으며, 이로 인해 캐시의 효율성이 상대적으로 떨어집니다.<br>

요약하자면, 요소의 접근이 주로 이루어지는 경우에는 ArrayList를, 요소의 삽입과 삭제가 빈번하게 이루어지는 경우에는 LinkedList를 사용하는 것이 더 효율적일 수 있습니다."<br>
<br>
참고 - ArrayList 값 연속정 저장 : Random Access, LinkedList는 값이 산재되어 저장되어 있음<br>
첫번째 위치에 insert/remove DoublyLinkedList의 경우 O(1), ArrayList의 경우 O(N)<br>
마지막 위치에 insert/remove DoubleLinkedList의 경우 O(1), ArrayList의 경우 O(1) or O(N)<br>
중간에 insert/remove Doubly : O(N) or searchtime + O(1), ArrayList : O(N)<br>
값으로 search는 둘다 O(N)이지만 ArrayList가 나음<br>
인덱스로 값을 get, LinkedList의 경우 O(N), ArrayList의 경우 O(1)<br>
값으로 remove 시 둘다 O(N)<br>
</details>

<details markdown = "1">
<summary>왜 ArrayList의 캐시 효율성이 더 좋은지 가능한 상세히 설명해주세요</summary>
공간 지역성(spatial Locality)는 컴퓨터 프로그램에서 사용하는 데이터가 메모리의 특정 구간에 집중되어 있는 경향을 말합니다.<br>
즉, 한번 참조된 데이터 근처의 데이터가 곧 이어서 참조될 가능성이 높다는 의미이며, 이는 CPU 캐시의 설계와 밀접한 관계가 있습니다.<br>
CPU 캐시는 주기억장치(RAM)에 비해 매우 빠른 속도를 가지지만 그만큼 용량이 작아서 전체 메모리를 저장할 순 없습니다.<br>
따라서 CPU는 프로그램이 주로 참조하는 데이터를 캐시에 저장합니다. 이때 공간지역성이 있다면 한번 참조된 데이터 주변의 데이터가<br>
곧 이어서 참조될 가능성이 높으므로 이러한 데이터를 캐시에 미리 가져와 놓으면 메모리 접근 시간을 줄일 수 있습니다.<br>
ArrayList는 메모리 상에서 연속적인 데이터를 저장하는 구조를 가지고 있습니다. 따라서 한 데이터가 CPU 캐시에 로드되면 그 근처의 데이터도 함께 로드되게 됩니다.<br>
이후 이 근처의 데이터에 접근하게 되면, 이미 캐시에 데이터가 존재하므로 캐시 히트가 발생하고, 메모리 접근 시간이 크게 줄어듭니다.<br>
반면 LinkedList는 노드들이 메모리의 여기저기에 분산되어 저장됩니다.<br>
각 노드는 자신의 다음 노드에 대한 참조만을 가지고 있으며, 이 참조는 메모리상의 아무 곳에나 위치할 수 있습니다.<br>
따라서 한 노드를 참조했다고 해서 그 근처의 노드가 곧바로 참조될 확률이 낮습니다. 이것이 LinkedList에서 공간지역성이 보장되지 않는 이유입니다.<br>
이로 인해 LinkedList를 사용할때는 캐시 히트 가능성이 상대적으로 낮아지고, 이에 따라 캐시의 효율성이 떨어집니다.<br>
</details>

<details markdown = "1">
<summary>Array와 LinkedList의 차이점에 대해 설명해주세요</summary>
이둘의 주요 차이점은 데이터가 메모리에 저장되는 방식과 각 요소에 대한 접근 방식에 있습니다<br>
배열은 'Random Access'를 지원합니다. 이는 배열의 요소들이 메모리 상에서 연속적으로 위치하기 때문에 가능한 것입니다<br>
따라서, 인덱스를 통해 배열의 특정 요소에 직접 접근할 수 있으며, 이러한 접근은 일정한 시간복잡도인 O(1)를 가집니다<br>
반면에 LinkedList는 'Sequential Access'를 지원합니다. LinkedList의 요소들은 메모리 상의 임의의 위치에 있으며, 각 요소(노드)는 다음 요소를 가리키는 링크를 가지고 있습니다<br>
이 링크를 따라가면서 요소에 접근해야 하기 때문에, 특정 요소에 접근하는 데는 시간복잡도 O(N)이 소요됩니다<br>
배열에서 요소의 삽입 또는 삭제는 복잡한 작업입니다. 배열은 고정된 크기를 가지므로, 삽입 또는 삭제를 위해서는 배열의 크기를 조정하거나, 요소들을 재배치해야 합니다. <br>
이러한 작업은 시간복잡도 O(N)이 소요됩니다.<br>
반면에 LinkedList에서는 삽입 및 삭제 작업이 상대적으로 간단합니다. 특정 위치에 삽입 또는 삭제를 위해서는 단지 몇 개의 링크를 조정하면 되므로, 이 작업은 일반적으로 시간복잡도 O(1)을 가집니다.<br>
배열은 '정적 메모리 할당'을 사용합니다. 즉, 배열이 생성될 때 그 크기가 고정되며, 메모리 상에 연속적으로 할당됩니다. 따라서, 배열의 크기는 변경할 수 없습니다.<br>
반면에 LinkedList는 '동적 메모리 할당'을 사용합니다. LinkedList의 요소(노드)는 필요에 따라 생성되고, 각 노드는 메모리 상의 임의의 위치에 할당됩니다. 이러한 특성 덕분에 LinkedList는 필요에 따라 크기를 동적으로 변경할 수 있습니다."<br>
<br>
참고 -  배열은 스택 영역에 할당되고, LinkedList는 힙 영역에 할당되는 것이 일반적입니다.
</details>